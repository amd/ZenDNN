# ******************************************************************************
# Copyright (c) 2025 Advanced Micro Devices, Inc.
# All rights reserved.
# ******************************************************************************
name: PR Status Notification (Main Branch)
on:
  pull_request:
    branches: [main]
    types: [opened, reopened, synchronize]

permissions:
  checks: read
  pull-requests: read
  contents: read
  actions: read

jobs:
  notify_teams:
    runs-on: amd-zenai-arc-xsmall-dind
    timeout-minutes: 90
    if: github.actor != 'github-actions[bot]'
    
    steps:
      - name: Get PR Info
        id: pr_info
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            return {
              number: pr.number,
              title: pr.title,
              url: pr.html_url,
              head_sha: pr.head.sha,
              author: pr.user.login,
              created_at: pr.created_at
            };

      - name: Find External Workflows for Current PR
        id: find_external
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ZIAIE_PAT }}
          script: |
            const pr = JSON.parse(`${{ steps.pr_info.outputs.result }}`);
            
            console.log(`ðŸŽ¯ Finding external workflows triggered by PR #${pr.number}`);
            
            // Wait for triggers
            console.log('â³ Waiting 5 minutes for external workflows...');
            await new Promise(resolve => setTimeout(resolve, 300000));
            
            const foundWorkflows = [];
            const prCreatedTime = new Date(pr.created_at);
            
            const repos = [
              { 
                owner: 'AMD-Zenai', 
                repo: 'ZenDNN_PyTorch_Plugin', 
                expectedWorkflows: [
                  { pattern: 'zendnn-pr', type: 'ZenDNN PyTorch Plugin' },
                  { pattern: 'zentorch-zendnnl', type: 'ZenTorch ZenDNNL Plugin' }
                ]
              },
              { 
                owner: 'AMD-Zenai', 
                repo: 'ZenDNN_TensorFlow_Plugin',
                expectedWorkflows: [
                  { pattern: 'zendnn-pr', type: 'ZenDNN TensorFlow Plugin' }
                ]
              }
            ];
            
            for (const repoInfo of repos) {
              try {
                console.log(`ðŸ” Checking ${repoInfo.repo}...`);
                
                const response = await github.rest.actions.listWorkflowRunsForRepo({
                  owner: repoInfo.owner,
                  repo: repoInfo.repo,
                  per_page: 50
                });
                
                // Find recent dispatch runs
                const recentRuns = response.data.workflow_runs.filter(run => {
                  if (run.event !== 'repository_dispatch') return false;
                  
                  const runTime = new Date(run.created_at);
                  const timeDiff = (runTime - prCreatedTime) / (1000 * 60);
                  return timeDiff >= -5 && timeDiff <= 120; // Extended time window
                });
                
                console.log(`   Found ${recentRuns.length} recent runs`);
                
                // Track found workflow types
                const foundTypes = new Set();
                
                for (const run of recentRuns) {
                  const runTitle = run.display_title || run.name || '';
                  console.log(`   Checking: "${runTitle}"`);
                  
                  // Check if this run is for our PR (more flexible matching)
                  const isPRMatch = new RegExp(`#${pr.number}\\b`, 'i').test(runTitle) ||
                                   new RegExp(`PR\\s*${pr.number}`, 'i').test(runTitle) ||
                                   new RegExp(`pull\\s*${pr.number}`, 'i').test(runTitle);
                  
                  if (isPRMatch) {
                    // Determine workflow type
                    let workflowType = null;
                    
                    for (const expected of repoInfo.expectedWorkflows) {
                      if (runTitle.toLowerCase().includes(expected.pattern.toLowerCase()) && 
                          !foundTypes.has(expected.type)) {
                        workflowType = expected.type;
                        foundTypes.add(workflowType);
                        break;
                      }
                    }
                    
                    // Fallback: if no specific pattern match, use repo default
                    if (!workflowType && foundTypes.size < repoInfo.expectedWorkflows.length) {
                      workflowType = repoInfo.expectedWorkflows.find(w => !foundTypes.has(w.type))?.type;
                      if (workflowType) foundTypes.add(workflowType);
                    }
                    
                    if (workflowType) {
                      console.log(`   âœ… Found: ${workflowType}`);
                      foundWorkflows.push({
                        id: run.id,
                        name: workflowType,
                        status: run.conclusion || run.status,
                        url: run.html_url,
                        repository: `${repoInfo.owner}/${repoInfo.repo}`
                      });
                    }
                  }
                }
                
              } catch (error) {
                console.log(`âŒ Error checking ${repoInfo.repo}: ${error.message}`);
              }
            }
            
            console.log(`ðŸŽ¯ Found ${foundWorkflows.length}/3 external workflows`);
            return { workflows: foundWorkflows };

      - name: Monitor All Checks
        id: monitor_checks
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ZIAIE_PAT }}
          script: |
            const pr = JSON.parse(`${{ steps.pr_info.outputs.result }}`);
            const externalResult = JSON.parse(`${{ steps.find_external.outputs.result }}`);
            
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const ref = pr.head_sha;
            
            console.log(`ðŸ” Monitoring checks for PR #${pr.number}`);
            
            const getAllChecks = async () => {
              const allChecks = [];
              
              try {
                // Get workflow runs
                const workflowResp = await github.rest.actions.listWorkflowRunsForRepo({
                  owner, repo, head_sha: ref, per_page: 100
                });
                
                workflowResp.data.workflow_runs.forEach(run => {
                  const name = run.name.toLowerCase();
                  
                  if (run.id === context.runId || 
                      name.includes('notification') || 
                      name.includes('notify') ||
                      name.includes('intelligent analysis')) {
                    return;
                  }
                  
                  allChecks.push({
                    name: run.name,
                    status: run.conclusion || run.status,
                    url: run.html_url,
                    type: 'local'
                  });
                });
                
                // Get check runs
                const checkResp = await github.rest.checks.listForRef({
                  owner, repo, ref, per_page: 100
                });
                
                checkResp.data.check_runs.forEach(check => {
                  const name = check.name.toLowerCase();
                  
                  if (name.includes('notification') || 
                      name.includes('notify') ||
                      name.includes('intelligent analysis')) {
                    return;
                  }
                  
                  if (!allChecks.find(c => c.name === check.name)) {
                    allChecks.push({
                      name: check.name,
                      status: check.conclusion || check.status,
                      url: check.html_url,
                      type: 'local'
                    });
                  }
                });
                
                // Get status checks
                const statusResp = await github.rest.repos.getCombinedStatusForRef({
                  owner, repo, ref
                });
                
                statusResp.data.statuses.forEach(status => {
                  if (!allChecks.find(c => c.name === status.context)) {
                    allChecks.push({
                      name: status.context,
                      status: status.state,
                      url: status.target_url,
                      type: 'local'
                    });
                  }
                });
                
                // Add external workflows with updated status
                for (const ext of externalResult.workflows) {
                  try {
                    const [extOwner, extRepo] = ext.repository.split('/');
                    const extResp = await github.rest.actions.getWorkflowRun({
                      owner: extOwner,
                      repo: extRepo,
                      run_id: ext.id
                    });
                    
                    allChecks.push({
                      name: ext.name,
                      status: extResp.data.conclusion || extResp.data.status,
                      url: extResp.data.html_url,
                      type: 'external'
                    });
                  } catch (error) {
                    allChecks.push({
                      name: ext.name,
                      status: ext.status,
                      url: ext.url,
                      type: 'external'
                    });
                  }
                }
                
                return allChecks;
                
              } catch (error) {
                console.log(`âŒ Error: ${error.message}`);
                return [];
              }
            };
            
            // Wait and monitor
            console.log('â³ Waiting 5 minutes...');
            await new Promise(resolve => setTimeout(resolve, 300000));
            
            let checks = await getAllChecks();
            let attempts = 0;
            const maxAttempts = 30;
            
            while (attempts < maxAttempts) {
              const running = checks.filter(c => 
                ['in_progress', 'queued', 'pending', 'waiting'].includes(c.status)
              );
              
              if (running.length === 0) {
                console.log(`âœ… All checks completed after ${attempts}m`);
                break;
              }
              
              attempts++;
              if (attempts >= maxAttempts) break;
              
              await new Promise(resolve => setTimeout(resolve, 60000));
              checks = await getAllChecks();
            }
            
            return { 
              checks, 
              total: checks.length,
              external_count: checks.filter(c => c.type === 'external').length,
              completed_in_minutes: attempts
            };

      - name: Send Teams Notification
        env:
          TEAMS_WEBHOOK_URL: ${{ secrets.TEAMS_WEBHOOK_URL }}
        run: |
          pr_json='${{ steps.pr_info.outputs.result }}'
          checks_json='${{ steps.monitor_checks.outputs.result }}'

          # Parse data
          PR_NUMBER=$(echo "$pr_json" | jq -r '.number')
          PR_TITLE=$(echo "$pr_json" | jq -r '.title' | sed 's/"/\\"/g' | sed "s/'/\\'/g")
          PR_URL=$(echo "$pr_json" | jq -r '.url')
          PR_AUTHOR=$(echo "$pr_json" | jq -r '.author')
          HEAD_SHA=$(echo "$pr_json" | jq -r '.head_sha' | cut -c1-7)

          CHECKS=$(echo "$checks_json" | jq -c '.checks // []')
          TOTAL_COUNT=$(echo "$checks_json" | jq -r '.total // 0')
          EXTERNAL_COUNT=$(echo "$checks_json" | jq -r '.external_count // 0')
          COMPLETION_TIME=$(echo "$checks_json" | jq -r '.completed_in_minutes // 0')
          
          # Count statuses
          SUCCESS_COUNT=$(echo "$CHECKS" | jq '[.[] | select(.status == "success")] | length')
          FAILED_COUNT=$(echo "$CHECKS" | jq '[.[] | select(.status == "failure")] | length')
          CANCELLED_COUNT=$(echo "$CHECKS" | jq '[.[] | select(.status == "cancelled")] | length')
          SKIPPED_COUNT=$(echo "$CHECKS" | jq '[.[] | select(.status == "skipped")] | length')
          PENDING_COUNT=$(echo "$CHECKS" | jq '[.[] | select(.status == "in_progress" or .status == "pending" or .status == "queued")] | length')

          # Overall status
          if [ "$FAILED_COUNT" -gt 0 ]; then
            ICON="ðŸ”´"
            STATUS="âŒ SOME CHECKS FAILED"
            COLOR="Attention"
          elif [ "$PENDING_COUNT" -gt 0 ]; then
            ICON="ðŸŸ¡"
            STATUS="â³ CHECKS RUNNING"
            COLOR="Warning"
          else
            ICON="ðŸŸ¢"
            STATUS="âœ… ALL CHECKS PASSED"
            COLOR="Good"
          fi

          # Completion message
          if [ "$COMPLETION_TIME" -gt 0 ]; then
            COMPLETION_MSG="All $TOTAL_COUNT workflows completed in ${COMPLETION_TIME}m"
          else
            COMPLETION_MSG="All $TOTAL_COUNT workflows completed"
          fi

          # Build check list (NO TYPE LABELS)
          CHECKS_LIST=""
          CHECK_COUNT=$(echo "$CHECKS" | jq 'length')
          
          for i in $(seq 0 $((CHECK_COUNT - 1))); do
            NAME=$(echo "$CHECKS" | jq -r ".[$i].name" | sed 's/"/\\"/g')
            STATUS_VAL=$(echo "$CHECKS" | jq -r ".[$i].status | ascii_upcase")
            URL=$(echo "$CHECKS" | jq -r ".[$i].url // \"\"")
            TYPE=$(echo "$CHECKS" | jq -r ".[$i].type")
            
            # Status color
            case "$STATUS_VAL" in
              "SUCCESS") STATUS_COLOR="Good"; STATUS_WEIGHT="Bolder" ;;
              "FAILURE") STATUS_COLOR="Attention"; STATUS_WEIGHT="Bolder" ;;
              "CANCELLED") STATUS_COLOR="Warning"; STATUS_WEIGHT="Bolder" ;;
              "SKIPPED") STATUS_COLOR="Accent"; STATUS_WEIGHT="Bolder" ;;
              *) STATUS_COLOR="Default"; STATUS_WEIGHT="Normal" ;;
            esac
            
            # Create check block (NO LABELS)
            CHECK_BLOCK='{
              "type": "RichTextBlock",
              "inlines": [
                {"type": "TextRun", "text": "â€¢ "},
                {
                  "type": "TextRun", 
                  "text": "'$NAME'", 
                  "selectAction": {"type": "Action.OpenUrl", "url": "'$URL'"}
                },
                {"type": "TextRun", "text": " - "},
                {
                  "type": "TextRun", 
                  "text": "'$STATUS_VAL'", 
                  "color": "'$STATUS_COLOR'", 
                  "weight": "'$STATUS_WEIGHT'"
                }
              ],
              "spacing": "None"
            }'
            
            if [ -z "$CHECKS_LIST" ]; then
              CHECKS_LIST="$CHECK_BLOCK"
            else
              CHECKS_LIST="$CHECKS_LIST,$CHECK_BLOCK"
            fi
          done

          # Create Teams card (SIMPLIFIED)
          cat > card.json <<EOF
          {
            "type": "message",
            "attachments": [{
              "contentType": "application/vnd.microsoft.card.adaptive",
              "content": {
                "type": "AdaptiveCard",
                "version": "1.4",
                "body": [
                  {
                    "type": "TextBlock",
                    "text": "$ICON PR #$PR_NUMBER (Main) â€” $PR_TITLE",
                    "weight": "Bolder",
                    "size": "Medium",
                    "wrap": true
                  },
                  {
                    "type": "TextBlock",
                    "text": "$STATUS",
                    "weight": "Bolder",
                    "color": "$COLOR",
                    "size": "Large"
                  },
                  {
                    "type": "FactSet",
                    "facts": [
                      {"title": "Author:", "value": "$PR_AUTHOR"},
                      {"title": "Commit:", "value": "$HEAD_SHA"},
                      {"title": "Status:", "value": "$COMPLETION_MSG"},
                      {"title": "Total Workflows:", "value": "$TOTAL_COUNT"},
                      {"title": "âœ… Passed:", "value": "$SUCCESS_COUNT"},
                      {"title": "âŒ Failed:", "value": "$FAILED_COUNT"},
                      {"title": "ðŸŸ  Cancelled:", "value": "$CANCELLED_COUNT"},
                      {"title": "â­ï¸ Skipped:", "value": "$SKIPPED_COUNT"}
                    ]
                  },
                  {
                    "type": "TextBlock",
                    "text": "**All PR Checks:**",
                    "weight": "Bolder",
                    "spacing": "Medium"
                  },
                  $CHECKS_LIST
                ],
                "actions": [
                  {"type": "Action.OpenUrl", "title": "View PR", "url": "$PR_URL"},
                  {"type": "Action.OpenUrl", "title": "View All Checks", "url": "https://github.com/${{ github.repository }}/pull/$PR_NUMBER/checks"}
                ]
              }
            }]
          }
          EOF

          curl -s -H "Content-Type: application/json" -d @card.json "$TEAMS_WEBHOOK_URL"
          echo "âœ… Teams notification sent!"
