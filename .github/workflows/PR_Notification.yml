# ******************************************************************************
# Copyright (c) 2025 Advanced Micro Devices, Inc.
# All rights reserved.
# ******************************************************************************
name: PR Status Notification
on:
  pull_request:
    types: [opened, reopened, synchronize]

permissions:
  checks: read
  pull-requests: read
  contents: read
  actions: read

jobs:
  notify_teams:
    runs-on: amd-zenai-arc-xsmall-dind
    timeout-minutes: 60
    # PREVENT SELF-TRIGGERING
    if: github.actor != 'github-actions[bot]'
    
    steps:
      - name: Get PR info
        id: pr_info
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            
            return {
              number: pr.number,
              title: pr.title || '',
              url: pr.html_url || '',
              head_sha: pr.head.sha,
              author: pr.user?.login || '',
              base_ref: pr.base?.ref || '',
              head_ref: pr.head?.ref || ''
            };
      - name: Find Triggered ZenTorch Workflow
        id: find_zentorch
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
           const pr = JSON.parse(`${{ steps.pr_info.outputs.result }}`);
            
           try {
             console.log(`Searching for ZenTorch workflow triggered by PR #${pr.number}`);
             console.log(`Looking for specific PR display in workflow logs...`);
             console.log(`Expected patterns:`);
             console.log(`  - "PR Number: #${pr.number}"`);
             console.log(`  - "ZenDNNL SHA: ${pr.head_sha}"`);
             console.log(`  - "PR Author: ${pr.author}"`);
             // Wait for trigger to happen and workflow to start
             await new Promise(resolve => setTimeout(resolve, 90000)); // Wait 1.5 minutes
             const runsResponse = await github.rest.actions.listWorkflowRuns({
               owner: 'AMD-Zenai',
               repo: 'ZenDNN_PyTorch_Plugin',
               workflow_id: 'zentorch_zendnnl_pr.yml',
                per_page: 10
             });
             console.log(`Found ${runsResponse.data.workflow_runs.length} total workflow runs`);
              // Filter to recent repository_dispatch runs
             const recentDispatchRuns = runsResponse.data.workflow_runs.filter(run => {
             const isRecentEnough = new Date(run.created_at) > new Date(Date.now() - 25 * 60 * 1000); // Last 25 minutes
             const isDispatchEvent = run.event === 'repository_dispatch';
             console.log(`Run ${run.id}: event=${run.event}, created=${run.created_at}, recent=${isRecentEnough}`);
             return isRecentEnough && isDispatchEvent;
             });
             console.log(`Found ${recentDispatchRuns.length} recent repository_dispatch runs to check`);
             // Check each recent run's logs for our specific PR display
             for (const run of recentDispatchRuns) {
               console.log(`\nðŸ” Checking logs for workflow run ${run.id} (${run.html_url})...`);
               try {
                // Get all jobs for this workflow run
                const jobsResp = await github.rest.actions.listJobsForWorkflowRun({
                  owner: 'AMD-Zenai',
                  repo: 'ZenDNN_PyTorch_Plugin',
                  run_id: run.id
                });
            
             console.log(`Found ${jobsResp.data.jobs.length} jobs in run ${run.id}`);
            
             // Look for jobs that likely contain the display step
             for (const job of jobsResp.data.jobs) {
              console.log(`  ðŸ“‹ Checking job: "${job.name}" (status: ${job.status})`);
              
             // Only check jobs that have started and have logs
              if (['completed', 'in_progress', 'success', 'failure'].includes(job.status) && job.id) {
                try {
                  console.log(`    ðŸ“¥ Downloading logs for job ${job.id}...`);
                  
                  // Get the job logs
                  const logsResp = await github.rest.actions.downloadJobLogsForWorkflowRun({
                    owner: 'AMD-Zenai',
                    repo: 'ZenDNN_PyTorch_Plugin',
                    job_id: job.id
                  });
                  // Fetch the actual log content
                  if (logsResp.url) {
                    const logContent = await fetch(logsResp.url);
                    const logText = await logContent.text();
                    
                    console.log(`    ðŸ“ Downloaded ${logText.length} characters of logs`);
                    
                    // Look for the specific display patterns from your output
                    const exactMatches = [
                      `PR Number: #${pr.number}`,                    // Exact PR number match
                      `ZenDNNL SHA: ${pr.head_sha}`,                 // Exact SHA match  
                      `PR Author: ${pr.author}`                      // Exact author match
                    ];
                    
                    const partialMatches = [
                      `PR Number: #${pr.number}`,
                      `ZenDNNL SHA: ${pr.head_sha.substring(0, 12)}`, // First 12 chars of SHA
                      `PR Title: ${pr.title.substring(0, 20)}`        // First 20 chars of title
                    ];
                    
                    let exactMatchCount = 0;
                    let partialMatchCount = 0;
                    let matchedPatterns = [];
                    
                    // Check for exact matches
                    for (const pattern of exactMatches) {
                      if (logText.includes(pattern)) {
                        exactMatchCount++;
                        matchedPatterns.push(`EXACT: ${pattern}`);
                        console.log(`    âœ… EXACT MATCH: "${pattern}"`);
                      }
                    }
                    // Check for partial matches
                    for (const pattern of partialMatches) {
                      if (logText.includes(pattern)) {
                        partialMatchCount++;
                        matchedPatterns.push(`PARTIAL: ${pattern}`);
                        console.log(`    âœ… PARTIAL MATCH: "${pattern}"`);
                      }
                    }
                    
                    // Require at least 2 exact matches for high confidence
                    if (exactMatchCount >= 2) {
                      console.log(`\nðŸŽ¯ HIGH CONFIDENCE MATCH FOUND!`);
                      console.log(`Run ID: ${run.id}`);
                      console.log(`URL: ${run.html_url}`);
                      console.log(`Exact matches: ${exactMatchCount}`);
                      console.log(`Matched patterns: ${matchedPatterns.join(', ')}`);
                      console.log(`Job that contained matches: ${job.name}`);
                      
                      return {
                        found: true,
                        external_run_id: run.id,
                        external_run_url: run.html_url,
                        external_repo: 'AMD-Zenai/ZenDNN_PyTorch_Plugin',
                        external_status: run.conclusion || run.status,
                        match_reason: 'high_confidence_log_match',
                        exact_matches: exactMatchCount,
                        matched_patterns: matchedPatterns,
                        matched_job: job.name,
                        run_created: run.created_at
                      };
                    }
                    // Medium confidence: 1 exact match or 2+ partial matches
                    else if (exactMatchCount >= 1 || partialMatchCount >= 2) {
                      console.log(`    ðŸŸ¡ Medium confidence match found (${exactMatchCount} exact, ${partialMatchCount} partial)`);
                      
                      // Store as potential match, continue checking other runs
                      var potentialMatch = {
                        found: true,
                        external_run_id: run.id,
                        external_run_url: run.html_url,
                        external_repo: 'AMD-Zenai/ZenDNN_PyTorch_Plugin',
                        external_status: run.conclusion || run.status,
                        match_reason: 'medium_confidence_log_match',
                        exact_matches: exactMatchCount,
                        partial_matches: partialMatchCount,
                        matched_patterns: matchedPatterns,
                        matched_job: job.name,
                        run_created: run.created_at
                      };
                    }
                    
                  } else {
                    console.log(`    âš ï¸ No log URL returned for job ${job.id}`);
                  }
                  
                } catch (logError) {
                  console.log(`    âŒ Error getting logs for job ${job.id}: ${logError.message}`);
                  
                  if (logError.status === 404) {
                    console.log(`    ðŸ“„ Job ${job.id} logs not available yet`);
                  }
                }
              } else {
                console.log(`    â­ï¸ Skipping job ${job.id} (status: ${job.status})`);
              }
            }
            
           } catch (jobError) {
            console.log(`âŒ Error checking jobs for run ${run.id}: ${jobError.message}`);
           }
           }
           // If we found a potential match but no high confidence match, use it
           if (typeof potentialMatch !== 'undefined') {
            console.log(`\nðŸŸ¡ Using medium confidence match: ${potentialMatch.external_run_url}`);
            return potentialMatch;
           }
           // Fallback: Use most recent repository_dispatch run
           if (recentDispatchRuns.length > 0) {
             const mostRecent = recentDispatchRuns[0];
             console.log(`\nâš ï¸ No log matches found, using most recent dispatch run: ${mostRecent.id}`);
             return {
               found: true,
               external_run_id: mostRecent.id,
               external_run_url: mostRecent.html_url,
               external_repo: 'AMD-Zenai/ZenDNN_PyTorch_Plugin',
               external_status: mostRecent.conclusion || mostRecent.status,
               match_reason: 'most_recent_fallback',
               run_created: mostRecent.created_at
             };
            }   
            console.log('âŒ No matching triggered workflow found');
            return {
              found: false,
              external_run_id: null,
              external_run_url: '',
              external_repo: 'AMD-Zenai/ZenDNN_PyTorch_Plugin',
              external_status: 'not_found',
              match_reason: 'no_match'
            };
           } catch (error) {
             console.log(`âŒ Error finding triggered workflow: ${error.message}`);
             return {
               found: false,
               external_run_id: null,
               external_run_url: '',
               external_repo: '',
               external_status: 'error',
               error: error.message,
               match_reason: 'error'
             };
           }
                    
            
      - name: Wait for ALL workflows to complete
        id: wait_for_completion
        uses: actions/github-script@v7
        with:
          script: |
            const pr = JSON.parse(`\${{ steps.pr_info.outputs.result }}`);
            const zentorchResult = JSON.parse(`\${{ steps.trigger_zentorch.outputs.result || '{}' }}`);
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const ref = pr.head_sha;

            // External repo details
            const externalRunId = zentorchResult.external_run_id;
            const externalRepo = zentorchResult.external_repo || '';
            const [externalOwner, externalRepoName] = externalRepo.split('/');
            
            console.log(`Monitoring workflows for PR #${pr.number}, commit: ${ref}`);
            console.log(`Current workflow run ID: ${context.runId}`);

             if (externalRunId) {
              console.log(`Also monitoring triggered ZenTorch workflow: ${zentorchResult.external_run_url}`);
            } else {
              console.log(`No triggered ZenTorch workflow found: ${zentorchResult.error || 'Not triggered yet'}`);
            }
            
            const checkAllWorkflows = async () => {
              try {
                // Define EXACTLY which workflows we want to monitor (WHITELIST APPROACH)
                const importantWorkflows = [
                  'commit message enforcement',
                  'zendnnl_build_pr', 
                  'check-zentorch-status',
                  'asan-build',
                  'zendnnl_build_push',
                  'check jira id',
                  'verify jira id',
                  'check license headers',
                  'verify license headers', 
                  'trigger-zentorch-zendnnl'
                ];

                // Get workflow runs - ONLY include important ones
                const workflowResp = await github.rest.actions.listWorkflowRunsForRepo({
                  owner,
                  repo,
                  head_sha: ref,
                  per_page: 100
                });
                
                const workflows = (workflowResp.data.workflow_runs || [])
                  .filter(run => {
                    const name = run.name.toLowerCase();
                    const isImportant = importantWorkflows.some(important => 
                      name.includes(important.toLowerCase())
                    );
                    const isSelf = run.id === context.runId;
                    
                    if (isSelf) {
                      console.log(`Excluding self workflow: ${run.name} (ID: ${run.id})`);
                      return false;
                    }
                    
                    if (!isImportant) {
                      console.log(`Excluding non-important workflow: ${run.name}`);
                      return false;
                    }
                    
                    return true;
                  });

                // Get check runs - ONLY include important ones
                const checkResp = await github.rest.checks.listForRef({
                  owner,
                  repo,
                  ref,
                  per_page: 100
                });
                
                const checks = (checkResp.data.check_runs || [])
                  .filter(check => {
                    const name = check.name.toLowerCase();
                    const isImportant = importantWorkflows.some(important => 
                      name.includes(important.toLowerCase())
                    );
                    
                    // Explicitly exclude notification-related checks
                    const isNotification = name.includes('notify') || 
                                         name.includes('notification') ||
                                         name === 'notify_teams';
                    
                    if (isNotification) {
                      console.log(`Excluding notification check: ${check.name}`);
                      return false;
                    }
                    
                    if (!isImportant) {
                      console.log(`Excluding non-important check: ${check.name}`);
                      return false;
                    }
                    
                    return true;
                  });
                // Get external workflow status
                let externalWorkflow = null;
                if (externalRunId && externalOwner && externalRepoName) {
                  try {
                    const externalResp = await github.rest.actions.getWorkflowRun({
                      owner: externalOwner,
                      repo: externalRepoName,
                      run_id: externalRunId
                    });
                    
                   externalWorkflow = {
                      id: externalResp.data.id,
                      name: `${externalRepoName}: ${externalResp.data.display_title || externalResp.data.name}`,
                      status: externalResp.data.conclusion || externalResp.data.status,
                      url: externalResp.data.html_url,
                      type: 'triggered_workflow_run',
                      repository: `${externalOwner}/${externalRepoName}`,
                      started_at: externalResp.data.created_at,
                      updated_at: externalResp.data.updated_at,
                      event: externalResp.data.event
                    };
                    
                   console.log(`Triggered ZenTorch workflow: ${externalWorkflow.name} - ${externalWorkflow.status}`);
                  } catch (error) {
                    console.log(`Could not get triggered ZenTorch workflow: ${error.message}`);
                  }
                } else {
                  // If we haven't found the triggered workflow yet, try to find it again
                  if (!zentorchResult.found) {
                    console.log('Attempting to find triggered workflow again...');
                    try {
                      const runsResponse = await github.rest.actions.listWorkflowRuns({
                        owner: 'AMD-Zenai',
                        repo: 'ZenDNN_PyTorch_Plugin',
                        workflow_id: 'zentorch_zendnnl_pr.yml',
                        per_page: 5
                      });
                      const recentRuns = runsResponse.data.workflow_runs.filter(run => {
                        const isRecent = new Date(run.created_at) > new Date(Date.now() - 15 * 60 * 1000);
                        const isDispatch = run.event === 'repository_dispatch';
                        return isRecent && isDispatch;
                      });
                      
                      if (recentRuns.length > 0) {
                        const latestRun = recentRuns[0];
                        externalWorkflow = {
                          id: latestRun.id,
                          name: `ZenDNN_PyTorch_Plugin: ${latestRun.display_title || latestRun.name}`,
                          status: latestRun.conclusion || latestRun.status,
                          url: latestRun.html_url,
                          type: 'triggered_workflow_run',
                          repository: 'AMD-Zenai/ZenDNN_PyTorch_Plugin',
                          started_at: latestRun.created_at,
                          updated_at: latestRun.updated_at,
                          event: latestRun.event
                        };
                        console.log(`Found triggered workflow on retry: ${externalWorkflow.name} - ${externalWorkflow.status}`);
                      }
                    } catch (error) {
                      console.log(`Retry search failed: ${error.message}`);
                      }
                  }
                }

                console.log(`Local workflows: ${workflows.length}, checks: ${checks.length}`);

                // Combine all workflow information
                const allRuns = [];
                 // Add local workflow runs
                workflows.forEach(run => {
                  allRuns.push({
                    id: run.id,
                    name: run.name,
                    status: run.conclusion || run.status,
                    url: run.html_url,
                    type: 'workflow_run',
                    repository: `${owner}/${repo}`,
                    started_at: run.created_at,
                    updated_at: run.updated_at
                  });
                });
                // Add local check runs (avoiding duplicates)
                checks.forEach(check => {
                  if (!allRuns.find(run => run.name === check.name)) {
                    allRuns.push({
                      id: check.id,
                      name: check.name,
                      status: check.conclusion || check.status,
                      url: check.html_url,
                      type: 'check_run',
                      repository: check.repository?.full_name || `${owner}/${repo}`,
                      started_at: check.started_at,
                      updated_at: check.completed_at
                    });
                  }
                });

                // Add external workflow if exists
                if (externalWorkflow) {
                  allRuns.push(externalWorkflow);
                }

                // Check completion status
                const running = allRuns.filter(r => 
                  ['in_progress', 'queued', 'pending', 'waiting', 'requested'].includes(r.status)
                );
                
                const completed = allRuns.filter(r => 
                  ['success', 'failure', 'cancelled', 'skipped'].includes(r.status)
                );

                console.log(`Found ${allRuns.length} RELEVANT workflows/checks (after whitelist filtering):`);
                allRuns.forEach(run => {
                  console.log(`  - ${run.name}: ${run.status} (${run.type})`);
                });
                
                if (running.length > 0) {
                  console.log(`Still running: ${running.map(r => r.name).join(', ')}`);
                }
                
                console.log(`Running: ${running.length}, Completed: ${completed.length}`);

                return {
                  all_complete: running.length === 0 && allRuns.length > 0,
                  workflows: allRuns,
                  running_count: running.length,
                  completed_count: completed.length,
                  total_count: allRuns.length,
                  external_workflow_url: externalWorkflow?.url || zentorchResult.external_run_url || ''
                };
              } catch (error) {
                console.log(`Error checking workflows: ${error.message}`);
                return { all_complete: false, workflows: [], error: error.message };
              }
            };

            // Give workflows time to start
            console.log('Waiting 2 minutes for workflows to initialize...');
            await new Promise(resolve => setTimeout(resolve, 120000));

            // Start monitoring
            let result = await checkAllWorkflows();
            let attempts = 0;
            const maxAttempts = 30; // Reduced from 58 - don't wait forever
            
            console.log(`Initial check: ${result.total_count} workflows found, ${result.running_count} still running`);

            // Keep checking until all workflows complete
            while (!result.all_complete && attempts < maxAttempts) {
              if (result.total_count === 0) {
                console.log('No workflows found yet, waiting for workflows to start...');
              } else {
                console.log(`Attempt ${attempts + 1}: ${result.running_count}/${result.total_count} workflows still running`);
              }
              
              await new Promise(resolve => setTimeout(resolve, 60000));
              result = await checkAllWorkflows();
              attempts++;
            }

            // FORCE COMPLETION if timeout reached
            if (!result.all_complete) {
              console.log(`Forcing completion after ${attempts} attempts. Proceeding with notification.`);
              result.all_complete = true; // Force completion to send notification
            } else {
              console.log(`All workflows completed after ${attempts} attempts!`);
            }

            return result;

      - name: Send Final Status Notification
        env:
          ZENDNNL_WEBHOOK_URL: ${{ secrets.ZENDNNL_WEBHOOK_URL }}
        run: |
          pr_json='${{ steps.pr_info.outputs.result }}'
          completion_json='${{ steps.wait_for_completion.outputs.result }}'

          PR_NUMBER=$(echo "$pr_json" | jq -r '.number // "N/A"')
          PR_TITLE=$(echo "$pr_json" | jq -r '.title // "N/A"' | sed 's/"/\\"/g' | sed "s/'/\\'/g")
          PR_URL=$(echo "$pr_json" | jq -r '.url // "N/A"')
          PR_AUTHOR=$(echo "$pr_json" | jq -r '.author // "N/A"')
          HEAD_SHA=$(echo "$pr_json" | jq -r '.head_sha // "N/A"')
          SHORT_SHA=$(echo "$HEAD_SHA" | cut -c1-7)

          ALL_COMPLETE=$(echo "$completion_json" | jq -r '.all_complete // false')
          TOTAL_COUNT=$(echo "$completion_json" | jq -r '.total_count // 0')
          RUNNING_COUNT=$(echo "$completion_json" | jq -r '.running_count // 0')
          EXTERNAL_WORKFLOW_URL=$(echo "$completion_json" | jq -r '.external_workflow_url // ""')

          WORKFLOWS=$(echo "$completion_json" | jq -c '.workflows // []')
          
          SUCCESS_COUNT=$(echo "$WORKFLOWS" | jq '[.[] | select(.status == "success")] | length')
          FAILED_COUNT=$(echo "$WORKFLOWS" | jq '[.[] | select(.status == "failure")] | length')
          CANCELLED_COUNT=$(echo "$WORKFLOWS" | jq '[.[] | select(.status == "cancelled")] | length')
          SKIPPED_COUNT=$(echo "$WORKFLOWS" | jq '[.[] | select(.status == "skipped")] | length')

          WORKFLOW_TEXTBLOCKS=""
          if [ "$TOTAL_COUNT" -gt 0 ]; then
             echo "Building individual TextBlocks for workflows..."
             WORKFLOW_COUNT=$(echo "$WORKFLOWS" | jq 'length')
             for i in $(seq 0 $((WORKFLOW_COUNT - 1))); do
               NAME=$(echo "$WORKFLOWS" | jq -r ".[$i].name")
               STATUS=$(echo "$WORKFLOWS" | jq -r ".[$i].status | ascii_upcase")
               URL=$(echo "$WORKFLOWS" | jq -r ".[$i].url")
               REPO=$(echo "$WORKFLOWS" | jq -r ".[$i].repository // \"\"")
               # Escape quotes for JSON
               NAME_SAFE=$(echo "$NAME" | sed 's/"/\\"/g')
               if [ "$REPO" != "$GITHUB_REPOSITORY" ] && [ -n "$REPO" ] && [ "$REPO" != "null" ]; then
                 WORKFLOW_TEXT="â€¢ [$NAME_SAFE]($URL) - **$STATUS** (ðŸ“ $REPO)"
               else
                 WORKFLOW_TEXT="â€¢ [$NAME_SAFE]($URL) - **$STATUS**"
               fi
               # Add TextBlock for this workflow
               TEXTBLOCK='{
                 "type": "TextBlock",
                 "text": "'$WORKFLOW_TEXT'",
                 "wrap": true,
                 "size": "Small",
                 "spacing": "None"
               }'
               if [ -z "$WORKFLOW_TEXTBLOCKS" ]; then
                 WORKFLOW_TEXTBLOCKS="$TEXTBLOCK"
               else
                 WORKFLOW_TEXTBLOCKS="$WORKFLOW_TEXTBLOCKS,$TEXTBLOCK"
               fi
             done
           else
            WORKFLOW_TEXTBLOCKS='{
              "type": "TextBlock",
              "text": "â€¢ No workflows found",
              "wrap": true,
              "size": "Small"
              }'
            fi

          # Determine overall status
          if [ "$FAILED_COUNT" -gt 0 ]; then
            ICON="ðŸ”´"
            STATUS_TEXT="âŒ SOME CHECKS FAILED"
            COLOR="Attention"
          elif [ "$CANCELLED_COUNT" -gt 0 ]; then
            ICON="ðŸŸ "
            STATUS_TEXT="ðŸŸ  SOME CHECKS CANCELLED"
            COLOR="Warning"
          elif [ "$ALL_COMPLETE" = "true" ] && [ "$SUCCESS_COUNT" -gt 0 ]; then
            ICON="ðŸŸ¢"
            STATUS_TEXT="âœ… ALL CHECKS PASSED"
            COLOR="Good"
          elif [ "$ALL_COMPLETE" = "true" ] && [ "$TOTAL_COUNT" -eq 0 ]; then
            ICON="âšª"
            STATUS_TEXT="âšª NO WORKFLOWS FOUND"
            COLOR="Default"
          else
            ICON="ðŸŸ¡"
            STATUS_TEXT="â³ CHECKS IN PROGRESS"
            COLOR="Warning"
          fi

          # Completion status
          if [ "$ALL_COMPLETE" = "true" ]; then
            COMPLETION_TEXT=" All $TOTAL_COUNT workflows completed"
          else
            COMPLETION_TEXT=" $RUNNING_COUNT of $TOTAL_COUNT workflows still running (timeout reached)"
          fi

          # Escape for JSON
          TITLE_SAFE="$ICON  PR #$PR_NUMBER â€” $PR_TITLE"
         

          # Create final status notification
          cat > card.json <<EOF
          {
            "type": "message",
            "attachments": [
              {
                 "contentType": "application/vnd.microsoft.card.adaptive",
                 "content": {
                    "\$schema": "http://adaptivecards.io/schemas/adaptive-card.json",
                    "type": "AdaptiveCard",
                    "version": "1.4",
                    "body": [
                      {
                         "type": "Container",
                         "items": [
                           {
                              "type": "TextBlock",
                              "text": "$TITLE_SAFE",
                              "wrap": true,
                              "weight": "Bolder",
                              "size": "Medium"
                           },
                           {
                              "type": "TextBlock",
                              "text": "$STATUS_TEXT",
                              "wrap": true,
                              "weight": "Bolder",
                              "color": "$COLOR",
                              "size": "Large"
                           },
                           {
                              "type": "FactSet",
                              "facts": [
                                    { "title": "Author:", "value": "$PR_AUTHOR" },
                                    { "title": "Commit:", "value": "$SHORT_SHA" },
                                    { "title": "Status:", "value": "$COMPLETION_TEXT" },
                                    { "title": "Total Workflows:", "value": "$TOTAL_COUNT" },
                                    { "title": "âœ… Passed:", "value": "$SUCCESS_COUNT" },
                                    { "title": "âŒ Failed:", "value": "$FAILED_COUNT" },
                                    { "title": "ðŸŸ  Cancelled:", "value": "$CANCELLED_COUNT" },
                                    { "title": "â­ï¸ Skipped:", "value": "$SKIPPED_COUNT" }
                               ]
                              },
                              {
                                 "type": "TextBlock",
                                 "text": "**All Workflow Results:**",
                                 "wrap": true,
                                 "weight": "Bolder",
                                 "size": "Small",
                                 "spacing": "Medium"
                              },
                              $WORKFLOW_TEXTBLOCKS
                            ]
                          }
                        ],
                        "actions": [
                          {
                             "type": "Action.OpenUrl",
                             "title": "View PR",
                             "url": "$PR_URL"
                          },
                          {
                             "type": "Action.OpenUrl",
                             "title": "View All Checks",
                             "url": "https://github.com/${{ github.repository }}/pull/$PR_NUMBER/checks"
                          },
                          {
                              "type": "Action.OpenUrl",
                              "title": "View Commit",
                              "url": "https://github.com/${{ github.repository }}/commit/$HEAD_SHA"
                          }$(if [ -n "$EXTERNAL_WORKFLOW_URL" ]; then echo ',
                          {
                              "type": "Action.OpenUrl",
                              "title": "View ZenTorch Build",
                              "url": "'$EXTERNAL_WORKFLOW_URL'"
                          }'; fi)
                       ]
                   }
              }
             ]
          }
          EOF
           
           curl -s -H "Content-Type: application/json" \
            -d @card.json \
            "$ZENDNNL_WEBHOOK_URL" || (echo "Failed to send Teams message" && exit 1)

           

         
