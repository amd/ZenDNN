# ******************************************************************************
# Copyright (c) 2025 Advanced Micro Devices, Inc.
# All rights reserved.
# ******************************************************************************
# ******************************************************************************
# Copyright (c) 2025 Advanced Micro Devices, Inc.
# All rights reserved.
# ******************************************************************************
name: PR Status Notification (Main Branch)
on:
  pull_request:
    branches: [main]
    types: [opened, reopened, synchronize]

permissions:
  checks: read
  pull-requests: write
  contents: read
  actions: read
  issues: write 

jobs:
  notify_teams:
    runs-on: amd-zenai-arc-xsmall-dind
    timeout-minutes: 90
    if: github.actor != 'github-actions[bot]'
    
    steps:
      - name: Get PR Info
        id: pr_info
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            return {
              number: pr.number,
              title: pr.title,
              url: pr.html_url,
              head_sha: pr.head.sha,
              author: pr.user.login,
              created_at: pr.created_at
            };

      - name: Find External Workflows for Current PR
        id: find_external
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ZIAIE_PAT }}
          script: |
            const pr = JSON.parse(`${{ steps.pr_info.outputs.result }}`);
            
            console.log(`üéØ Finding external workflows triggered by PR #${pr.number}`);
            
            // Wait for triggers
            console.log('‚è≥ Waiting 5 minutes for external workflows...');
            await new Promise(resolve => setTimeout(resolve, 300000));
            
            const foundWorkflows = [];
            const prCreatedTime = new Date(pr.created_at);
            
            const repos = [
              { 
                owner: 'AMD-Zenai', 
                repo: 'ZenDNN_PyTorch_Plugin', 
                expectedWorkflows: [
                  { pattern: 'zendnn-pr', type: 'ZenDNN PyTorch Plugin' },
                  { pattern: 'zentorch-zendnnl', type: 'ZenTorch ZenDNNL Plugin' }
                ]
              },
              { 
                owner: 'AMD-Zenai', 
                repo: 'ZenDNN_TensorFlow_Plugin',
                expectedWorkflows: [
                  { pattern: 'zendnn-pr', type: 'ZenDNN TensorFlow Plugin' }
                ]
              }
            ];
            
            for (const repoInfo of repos) {
              try {
                console.log(`üîç Checking ${repoInfo.repo}...`);
                
                const response = await github.rest.actions.listWorkflowRunsForRepo({
                  owner: repoInfo.owner,
                  repo: repoInfo.repo,
                  per_page: 50
                });
                
                // Find recent dispatch runs
                const recentRuns = response.data.workflow_runs.filter(run => {
                  if (run.event !== 'repository_dispatch') return false;
                  
                  const runTime = new Date(run.created_at);
                  const timeDiff = (runTime - prCreatedTime) / (1000 * 60);
                  return timeDiff >= -10 && timeDiff <= 180; // Extended window: 10min before to 3h after
                });
                
                console.log(`   Found ${recentRuns.length} recent runs`);
                
                // Track found workflow types
                const foundTypes = new Set();
                
                for (const run of recentRuns) {
                  const runTitle = run.display_title || run.name || '';
                  console.log(`   üìã Checking: "${runTitle}"`);
                  
                  // ‚úÖ ENHANCED PR MATCHING - Multiple methods
                  let isPRMatch = false;
                  let matchMethod = '';
                  
                  // Method 1: Direct PR number in title
                  if (new RegExp(`#${pr.number}\\b`, 'i').test(runTitle) ||
                      new RegExp(`PR\\s*${pr.number}`, 'i').test(runTitle) ||
                      new RegExp(`pull\\s*${pr.number}`, 'i').test(runTitle)) {
                    isPRMatch = true;
                    matchMethod = 'title-match';
                  }
                  
                  // Method 2: Check job logs for PR reference (if title doesn't match)
                  if (!isPRMatch) {
                    try {
                      const jobsResp = await github.rest.actions.listJobsForWorkflowRun({
                        owner: repoInfo.owner,
                        repo: repoInfo.repo,
                        run_id: run.id
                      });
                      
                      for (const job of jobsResp.data.jobs.slice(0, 2)) {
                        if (isPRMatch) break;
                        
                        if (['completed', 'in_progress'].includes(job.status)) {
                          try {
                            const logsResp = await github.rest.actions.downloadJobLogsForWorkflowRun({
                              owner: repoInfo.owner,
                              repo: repoInfo.repo,
                              job_id: job.id
                            });
                            
                            const logsText = logsResp.data.toString();
                            
                            // Look for PR patterns in logs
                            const prPatterns = [
                              `PR Number: #${pr.number}`,
                              `zendnn_pr_number.*${pr.number}`,
                              `https://github.com/AMD-Zenai/ZenDNN/pull/${pr.number}`,
                              `Repository: AMD-Zenai/ZenDNN.*#${pr.number}`
                            ];
                            
                            if (prPatterns.some(pattern => new RegExp(pattern, 'is').test(logsText))) {
                              isPRMatch = true;
                              matchMethod = 'logs-match';
                              break;
                            }
                          } catch (logError) {
                            console.log(`      Logs not ready for job ${job.id}`);
                          }
                        }
                      }
                    } catch (jobError) {
                      console.log(`      Could not check jobs for run ${run.id}`);
                    }
                  }
                  
                  // Method 3: Smart timing match for very recent runs (within 30 min)
                  if (!isPRMatch) {
                    const runAge = (Date.now() - new Date(run.created_at)) / (1000 * 60);
                    if (runAge <= 30) {
                      const matchesExpectedPattern = repoInfo.expectedWorkflows.some(expected => 
                        runTitle.toLowerCase().includes(expected.pattern.toLowerCase())
                      );
                      
                      if (matchesExpectedPattern) {
                        isPRMatch = true;
                        matchMethod = 'smart-timing';
                      }
                    }
                  }
                  
                  if (isPRMatch) {
                    console.log(`      ‚úÖ MATCH found via ${matchMethod}!`);
                    
                    // Determine workflow type
                    let workflowType = null;
                    
                    for (const expected of repoInfo.expectedWorkflows) {
                      if (runTitle.toLowerCase().includes(expected.pattern.toLowerCase()) && 
                          !foundTypes.has(expected.type)) {
                        workflowType = expected.type;
                        foundTypes.add(workflowType);
                        break;
                      }
                    }
                    
                    // Fallback: if no specific pattern match, assign by order
                    if (!workflowType && foundTypes.size < repoInfo.expectedWorkflows.length) {
                      for (const expected of repoInfo.expectedWorkflows) {
                        if (!foundTypes.has(expected.type)) {
                          workflowType = expected.type;
                          foundTypes.add(workflowType);
                          break;
                        }
                      }
                    }
                    
                    if (workflowType) {
                      console.log(`      ‚úÖ Added: ${workflowType}`);
                      foundWorkflows.push({
                        id: run.id,
                        name: workflowType,
                        status: run.conclusion || run.status,
                        url: run.html_url, // ‚úÖ ENSURE URL is included
                        repository: `${repoInfo.owner}/${repoInfo.repo}`,
                        match_method: matchMethod
                      });
                    }
                  } else {
                    console.log(`      ‚ùå No match for "${runTitle}"`);
                  }
                }
                
                console.log(`   üìä Found ${foundTypes.size}/${repoInfo.expectedWorkflows.length} workflows for ${repoInfo.repo}`);
                
              } catch (error) {
                console.log(`‚ùå Error checking ${repoInfo.repo}: ${error.message}`);
              }
            }
            
            console.log(`\nüéØ TOTAL FOUND: ${foundWorkflows.length}/3 external workflows for PR #${pr.number}`);
            if (foundWorkflows.length > 0) {
              foundWorkflows.forEach(wf => {
                console.log(`  ‚úÖ ${wf.name}: ${wf.status} (${wf.match_method}) - ${wf.url}`);
              });
            } else {
              console.log(`\nüîç DEBUGGING: No external workflows found. Recent dispatch runs might not contain PR #${pr.number}`);
              console.log(`   Check if external repositories are properly triggered`);
              console.log(`   Check if PR number appears in workflow titles or logs`);
            }
            
            return { workflows: foundWorkflows };

      - name: Monitor All Checks
        id: monitor_checks
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ZIAIE_PAT }}
          script: |
            const pr = JSON.parse(`${{ steps.pr_info.outputs.result }}`);
            const externalResult = JSON.parse(`${{ steps.find_external.outputs.result }}`);
            
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const ref = pr.head_sha;
            
            console.log(`üîç Monitoring checks for PR #${pr.number} (commit: ${ref.substring(0, 7)})`);
            console.log(`External workflows found: ${externalResult.workflows.length}`);
            
            // ‚úÖ EXCLUSION LIST - Remove specific checks
            const excludedChecks = [
              'amd-zenai/zendnn_tensorflow_plugin ci',
              'amd-zenai/zendnn_pytorch_plugin ci', 
              'amd-zenai/zendnn_pytorch_plugin zendnnl ci',
              'check-commit-messages',
              'notification',
              'notify',
              'intelligent analysis'
            ];
            
            const isExcluded = (name) => {
              const lowerName = name.toLowerCase();
              return excludedChecks.some(excluded => lowerName.includes(excluded));
            };
            
            const getAllChecks = async () => {
              const allChecks = [];
              
              try {
                console.log(`üìä Getting all checks for commit ${ref.substring(0, 7)}...`);
                
                // Get workflow runs
                const workflowResp = await github.rest.actions.listWorkflowRunsForRepo({
                  owner, repo, head_sha: ref, per_page: 100
                });
                
                console.log(`   Found ${workflowResp.data.workflow_runs.length} workflow runs`);
                
                workflowResp.data.workflow_runs.forEach(run => {
                  // Skip self, excluded workflows
                  if (run.id === context.runId || isExcluded(run.name)) {
                    return;
                  }
                  
                  allChecks.push({
                    name: run.name,
                    status: run.conclusion || run.status,
                    url: run.html_url,
                    type: 'local'
                  });
                });
                
                // Get check runs
                const checkResp = await github.rest.checks.listForRef({
                  owner, repo, ref, per_page: 100
                });
                
                console.log(`   Found ${checkResp.data.check_runs.length} check runs`);
                
                checkResp.data.check_runs.forEach(check => {
                  // Skip excluded checks
                  if (isExcluded(check.name)) {
                    return;
                  }
                  
                  // Avoid duplicates
                  if (!allChecks.find(c => c.name === check.name)) {
                    allChecks.push({
                      name: check.name,
                      status: check.conclusion || check.status,
                      url: check.html_url,
                      type: 'local'
                    });
                  }
                });
                
                // Get status checks
                const statusResp = await github.rest.repos.getCombinedStatusForRef({
                  owner, repo, ref
                });
                
                console.log(`   Found ${statusResp.data.statuses.length} status checks`);
                
                statusResp.data.statuses.forEach(status => {
                  // Skip excluded status checks
                  if (isExcluded(status.context)) {
                    return;
                  }
                  
                  // Avoid duplicates
                  if (!allChecks.find(c => c.name === status.context)) {
                    allChecks.push({
                      name: status.context,
                      status: status.state,
                      url: status.target_url,
                      type: 'local'
                    });
                  }
                });
                
                // Add external workflows with updated status AND preserved URLs
                for (const ext of externalResult.workflows) {
                  try {
                    const [extOwner, extRepo] = ext.repository.split('/');
                    const extResp = await github.rest.actions.getWorkflowRun({
                      owner: extOwner,
                      repo: extRepo,
                      run_id: ext.id
                    });
                    
                    allChecks.push({
                      name: ext.name,
                      status: extResp.data.conclusion || extResp.data.status,
                      url: extResp.data.html_url, // ‚úÖ ENSURE URL is from API response
                      type: 'external'
                    });
                  } catch (error) {
                    console.log(`   ‚ö†Ô∏è Could not update external workflow ${ext.id}, using cached data`);
                    allChecks.push({
                      name: ext.name,
                      status: ext.status,
                      url: ext.url, // ‚úÖ FALLBACK to original URL
                      type: 'external'
                    });
                  }
                }
                
                console.log(`üìã Total checks collected: ${allChecks.length}`);
                console.log(`   Local: ${allChecks.filter(c => c.type === 'local').length}`);
                console.log(`   External: ${allChecks.filter(c => c.type === 'external').length}`);
                
                // ‚úÖ LOG EXCLUDED CHECKS
                const excludedCount = (workflowResp.data.workflow_runs.length + 
                                    checkResp.data.check_runs.length + 
                                    statusResp.data.statuses.length) - allChecks.length + externalResult.workflows.length;
                console.log(`   Excluded: ${excludedCount} checks (CI status checks, commit-messages, notifications)`);
                
                return allChecks;
                
              } catch (error) {
                console.log(`‚ùå Error getting checks: ${error.message}`);
                return [];
              }
            };
            
            // Initial wait
            console.log('‚è≥ Waiting 5 minutes for all checks to start...');
            await new Promise(resolve => setTimeout(resolve, 300000));
            
            let checks = await getAllChecks();
            let attempts = 0;
            const maxAttempts = 30; // 30 minutes max
            
            console.log(`\nüîÑ Starting monitoring loop...`);
            
            // Wait for completion
            while (attempts < maxAttempts) {
              const running = checks.filter(c => 
                ['in_progress', 'queued', 'pending', 'waiting', 'requested'].includes(c.status)
              );
              
              const completed = checks.filter(c => 
                ['success', 'failure', 'cancelled', 'skipped', 'neutral', 'error'].includes(c.status)
              );
              
              console.log(`\nüìä Status Summary (attempt ${attempts + 1}):`);
              console.log(`   ‚úÖ Completed: ${completed.length}`);
              console.log(`   ‚è≥ Running: ${running.length}`);
              console.log(`   üìä Total: ${checks.length}`);
              
              if (running.length === 0) {
                console.log(`\nüéâ All ${checks.length} checks completed after ${attempts} minutes!`);
                break;
              }
              
              console.log(`\n‚è≥ Still waiting for:`);
              running.forEach(c => console.log(`   üîÑ ${c.name}: ${c.status}`));
              
              attempts++;
              if (attempts >= maxAttempts) {
                console.log(`\n‚è∞ Timeout after ${maxAttempts} minutes - forcing completion`);
                break;
              }
              
              await new Promise(resolve => setTimeout(resolve, 60000)); // Wait 1 minute
              checks = await getAllChecks();
            }
            
            const finalRunning = checks.filter(c => 
              ['in_progress', 'queued', 'pending', 'waiting', 'requested'].includes(c.status)
            ).length;
            
            return { 
              checks, 
              total: checks.length,
              external_count: checks.filter(c => c.type === 'external').length,
              completed_in_minutes: attempts,
              still_running: finalRunning
            };

      - name: Send Teams Notification
        env:
          TEAMS_WEBHOOK_URL: ${{ secrets.TEAMS_WEBHOOK_URL }}
        run: |
          pr_json='${{ steps.pr_info.outputs.result }}'
          checks_json='${{ steps.monitor_checks.outputs.result }}'

          echo "üì§ Building Teams notification..."

          # Parse data
          PR_NUMBER=$(echo "$pr_json" | jq -r '.number')
          PR_TITLE=$(echo "$pr_json" | jq -r '.title' | sed 's/"/\\"/g' | sed "s/'/\\'/g")
          PR_URL=$(echo "$pr_json" | jq -r '.url')
          PR_AUTHOR=$(echo "$pr_json" | jq -r '.author')
          HEAD_SHA=$(echo "$pr_json" | jq -r '.head_sha' | cut -c1-7)

          CHECKS=$(echo "$checks_json" | jq -c '.checks // []')
          TOTAL_COUNT=$(echo "$checks_json" | jq -r '.total // 0')
          EXTERNAL_COUNT=$(echo "$checks_json" | jq -r '.external_count // 0')
          COMPLETION_TIME=$(echo "$checks_json" | jq -r '.completed_in_minutes // 0')
          STILL_RUNNING=$(echo "$checks_json" | jq -r '.still_running // 0')
          
          # Count statuses
          SUCCESS_COUNT=$(echo "$CHECKS" | jq '[.[] | select(.status == "success")] | length')
          FAILED_COUNT=$(echo "$CHECKS" | jq '[.[] | select(.status == "failure")] | length')
          CANCELLED_COUNT=$(echo "$CHECKS" | jq '[.[] | select(.status == "cancelled")] | length')
          SKIPPED_COUNT=$(echo "$CHECKS" | jq '[.[] | select(.status == "skipped")] | length')
          NEUTRAL_COUNT=$(echo "$CHECKS" | jq '[.[] | select(.status == "neutral")] | length')
          ERROR_COUNT=$(echo "$CHECKS" | jq '[.[] | select(.status == "error")] | length')
          PENDING_COUNT=$(echo "$CHECKS" | jq '[.[] | select(.status == "in_progress" or .status == "pending" or .status == "queued" or .status == "waiting")] | length')

          echo "üìä Statistics (FILTERED - Excluded CI status checks and check-commit-messages):"
          echo "   Total: $TOTAL_COUNT ($((TOTAL_COUNT - EXTERNAL_COUNT)) local + $EXTERNAL_COUNT external)"
          echo "   Success: $SUCCESS_COUNT, Failed: $FAILED_COUNT, Skipped: $SKIPPED_COUNT"
          echo "   Completion time: ${COMPLETION_TIME}m, Still running: $STILL_RUNNING"

          # Overall status
          if [ "$FAILED_COUNT" -gt 0 ] || [ "$ERROR_COUNT" -gt 0 ]; then
            ICON="üî¥"
            STATUS="‚ùå SOME CHECKS FAILED"
            COLOR="Attention"
          elif [ "$PENDING_COUNT" -gt 0 ]; then
            ICON="üü°"
            STATUS="‚è≥ CHECKS STILL RUNNING"
            COLOR="Warning"
          elif [ "$CANCELLED_COUNT" -gt 0 ]; then
            ICON="üü†"
            STATUS="üü† SOME CHECKS CANCELLED"
            COLOR="Warning"
          else
            ICON="üü¢"
            STATUS="‚úÖ ALL CHECKS PASSED"
            COLOR="Good"
          fi

          # Completion message
          if [ "$STILL_RUNNING" -gt 0 ]; then
            COMPLETION_MSG="All $TOTAL_COUNT workflows completed in ${COMPLETION_TIME}m (${STILL_RUNNING} still running)"
          else
            COMPLETION_MSG="All $TOTAL_COUNT workflows completed in ${COMPLETION_TIME}m"
          fi

          # Build check list - ENSURE URLs ARE PRESERVED
          echo "üî® Building filtered check list..."
          CHECKS_LIST=""
          CHECK_COUNT=$(echo "$CHECKS" | jq 'length')
          
          for i in $(seq 0 $((CHECK_COUNT - 1))); do
            NAME=$(echo "$CHECKS" | jq -r ".[$i].name" | sed 's/"/\\"/g')
            STATUS_VAL=$(echo "$CHECKS" | jq -r ".[$i].status | ascii_upcase")
            URL=$(echo "$CHECKS" | jq -r ".[$i].url // \"\"")
            TYPE=$(echo "$CHECKS" | jq -r ".[$i].type")
            
            # Validate URL
            if [ "$URL" = "null" ] || [ -z "$URL" ]; then
              URL="https://github.com/${{ github.repository }}/pull/$PR_NUMBER/checks"
            fi
            
            echo "   Adding: $NAME ($STATUS_VAL) - $URL"
            
            # Status color
            case "$STATUS_VAL" in
              "SUCCESS") STATUS_COLOR="Good"; STATUS_WEIGHT="Bolder" ;;
              "FAILURE") STATUS_COLOR="Attention"; STATUS_WEIGHT="Bolder" ;;
              "CANCELLED") STATUS_COLOR="Warning"; STATUS_WEIGHT="Bolder" ;;
              "SKIPPED") STATUS_COLOR="Default"; STATUS_WEIGHT="Bolder" ;;
              "NEUTRAL") STATUS_COLOR="Default"; STATUS_WEIGHT="Bolder" ;;
              "ERROR") STATUS_COLOR="Attention"; STATUS_WEIGHT="Bolder" ;;
              *) STATUS_COLOR="Default"; STATUS_WEIGHT="Normal" ;;
            esac
            
            # Create check block with clickable URLs
            CHECK_BLOCK='{
              "type": "RichTextBlock",
              "inlines": [
                {"type": "TextRun", "text": "‚Ä¢ "},
                {
                  "type": "TextRun", 
                  "text": "'$NAME'", 
                  "selectAction": {
                    "type": "Action.OpenUrl", 
                    "url": "'$URL'"
                  }
                },
                {"type": "TextRun", "text": " - "},
                {
                  "type": "TextRun", 
                  "text": "'$STATUS_VAL'", 
                  "color": "'$STATUS_COLOR'", 
                  "weight": "'$STATUS_WEIGHT'"
                }
              ],
              "spacing": "None"
            }'
            
            if [ -z "$CHECKS_LIST" ]; then
              CHECKS_LIST="$CHECK_BLOCK"
            else
              CHECKS_LIST="$CHECKS_LIST,$CHECK_BLOCK"
            fi
          done

          # Create Teams card
          echo "üî® Creating Teams card..."
          cat > card.json <<EOF
          {
            "type": "message",
            "attachments": [{
              "contentType": "application/vnd.microsoft.card.adaptive",
              "content": {
                "\$schema": "http://adaptivecards.io/schemas/adaptive-card.json",
                "type": "AdaptiveCard",
                "version": "1.4",
                "body": [
                  {
                    "type": "TextBlock",
                    "text": "$ICON PR #$PR_NUMBER (Main) ‚Äî $PR_TITLE",
                    "weight": "Bolder",
                    "size": "Medium",
                    "wrap": true
                  },
                  {
                    "type": "TextBlock",
                    "text": "$STATUS",
                    "weight": "Bolder",
                    "color": "$COLOR",
                    "size": "Large",
                    "wrap": true
                  },
                  {
                    "type": "FactSet",
                    "facts": [
                      {"title": "Author:", "value": "$PR_AUTHOR"},
                      {"title": "Commit:", "value": "$HEAD_SHA"},
                      {"title": "Status:", "value": "$COMPLETION_MSG"},
                      {"title": "Total Workflows:", "value": "$TOTAL_COUNT"},
                      {"title": "‚úÖ Passed:", "value": "$SUCCESS_COUNT"},
                      {"title": "‚ùå Failed:", "value": "$FAILED_COUNT"},
                      {"title": "üü† Cancelled:", "value": "$CANCELLED_COUNT"},
                      {"title": "‚è≠Ô∏è Skipped:", "value": "$SKIPPED_COUNT"}
                    ]
                  },
                  {
                    "type": "TextBlock",
                    "text": "**All PR Checks:**",
                    "weight": "Bolder",
                    "spacing": "Medium",
                    "wrap": true
                  },
                  $CHECKS_LIST
                ],
                "actions": [
                  {
                    "type": "Action.OpenUrl",
                    "title": "View PR",
                    "url": "$PR_URL"
                  },
                  {
                    "type": "Action.OpenUrl", 
                    "title": "View All Checks",
                    "url": "https://github.com/${{ github.repository }}/pull/$PR_NUMBER/checks"
                  },
                  {
                    "type": "Action.OpenUrl",
                    "title": "View Commit",
                    "url": "https://github.com/${{ github.repository }}/commit/$(echo "$pr_json" | jq -r '.head_sha')"
                  }
                ]
              }
            }]
          }
          EOF

          echo "üì§ Sending Teams notification..."
          curl -s -H "Content-Type: application/json" -d @card.json "$TEAMS_WEBHOOK_URL"
          
          if [ $? -eq 0 ]; then
            echo "‚úÖ Teams notification sent successfully!"
          else
            echo "‚ùå Failed to send Teams notification"
            exit 1
          fi

          echo "üéâ Workflow completed successfully!"

      - name: Notify PR Author via Comment
        if: always()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ZIAIE_PAT }}
          script: |
            try {
              const pr_json = JSON.parse(`${{ steps.pr_info.outputs.result }}`);
              const checks_json = JSON.parse(`${{ steps.monitor_checks.outputs.result }}`);

              const PR_NUMBER = pr_json.number;
              const PR_TITLE = pr_json.title;
              const PR_AUTHOR_RAW = pr_json.author;
              const PR_AUTHOR = pr_json.author.replace('_amdeng', '');
              const HEAD_SHA = pr_json.head_sha.substring(0, 7);
              const PR_URL = pr_json.url;

              const CHECKS = checks_json.checks || [];
              const TOTAL_COUNT = checks_json.total || 0;
              const EXTERNAL_COUNT = checks_json.external_count || 0;
              const COMPLETION_TIME = checks_json.completed_in_minutes || 0;
              const STILL_RUNNING = checks_json.still_running || 0;

              // Count statuses
              const SUCCESS_COUNT = CHECKS.filter(c => c.status === 'success').length;
              const FAILED_COUNT = CHECKS.filter(c => c.status === 'failure').length;
              const CANCELLED_COUNT = CHECKS.filter(c => c.status === 'cancelled').length;
              const SKIPPED_COUNT = CHECKS.filter(c => c.status === 'skipped').length;
              const ERROR_COUNT = CHECKS.filter(c => c.status === 'error').length;
              const PENDING_COUNT = CHECKS.filter(c => ['in_progress', 'pending', 'queued', 'waiting'].includes(c.status)).length;

              // Overall status
              let mainIcon, statusTitle, statusColor;
              if (FAILED_COUNT > 0 || ERROR_COUNT > 0) {
                mainIcon = "üî¥";
                statusTitle = "‚ùå Some Checks Failed";
                statusColor = "üî¥";
              } else if (PENDING_COUNT > 0 || STILL_RUNNING > 0) {
                mainIcon = "üü°";
                statusTitle = "‚è≥ Checks Still Running";
                statusColor = "üü°";
              } else if (CANCELLED_COUNT > 0) {
                mainIcon = "üü†";
                statusTitle = "üü† Some Checks Cancelled";
                statusColor = "üü†";
              } else {
                mainIcon = "üü¢";
                statusTitle = "‚úÖ All Checks Passed";
                statusColor = "üü¢";
              }

              // Completion message
              let completionMsg;
              if (STILL_RUNNING > 0) {
                completionMsg = `All ${TOTAL_COUNT} workflows completed in ${COMPLETION_TIME}m (${STILL_RUNNING} still running)`;
              } else {
                completionMsg = `All ${TOTAL_COUNT} workflows completed in ${COMPLETION_TIME}m`;
              }

              // Group checks by status for better organization
              const successChecks = CHECKS.filter(c => c.status === 'success');
              const failedChecks = CHECKS.filter(c => c.status === 'failure' || c.status === 'error');
              const cancelledChecks = CHECKS.filter(c => c.status === 'cancelled');
              const skippedChecks = CHECKS.filter(c => c.status === 'skipped');
              const pendingChecks = CHECKS.filter(c => ['in_progress', 'pending', 'queued', 'waiting'].includes(c.status));

              // Build organized check lists
              const buildCheckList = (checks, icon, label) => {
                if (checks.length === 0) return '';
                
                let list = `\n#### ${icon} ${label} (${checks.length})\n`;
                checks.forEach(check => {
                  const checkUrl = check.url || `https://github.com/${{ github.repository }}/pull/${PR_NUMBER}/checks`;
                  const externalLabel = check.type === 'external' ? ' *(External)*' : '';
                  list += `- [${check.name}](${checkUrl})${externalLabel}\n`;
                });
                return list;
              };

              const failedList = buildCheckList(failedChecks, '‚ùå', 'Failed Checks');
              const cancelledList = buildCheckList(cancelledChecks, 'üü†', 'Cancelled Checks');
              const pendingList = buildCheckList(pendingChecks, '‚è≥', 'Running Checks');
              const successList = buildCheckList(successChecks, '‚úÖ', 'Passed Checks');
              const skippedList = buildCheckList(skippedChecks, '‚è≠Ô∏è', 'Skipped Checks');

              // Create beautifully formatted comment
              const commentBody = `## ${mainIcon} ZenDNN PR #${PR_NUMBER} - Workflow Results
               > **Hey @${PR_AUTHOR_RAW}!** Your PR "${PR_TITLE}" workflow has completed. Here's a comprehensive summary:

              ---
              
              ### üìä **Workflow Summary**
              
              | **Field** | **Value** |
              |-----------|-----------|
              | **üë§ Author** | ${PR_AUTHOR} |
              | **üìù Title** | ${PR_TITLE} |
              | **üîó Commit** | [\`${HEAD_SHA}\`](https://github.com/${{ github.repository }}/commit/${pr_json.head_sha}) |
              | **‚è±Ô∏è Duration** | ${COMPLETION_TIME} minutes |
              | **üì¶ Total Workflows** | **${TOTAL_COUNT}** (${TOTAL_COUNT - EXTERNAL_COUNT} local + ${EXTERNAL_COUNT} external) |
              
              ---

              ### ${statusColor} **Results Overview**
              
              | Status | Count |
              |--------|-------|
              | ‚úÖ **Passed** | **${SUCCESS_COUNT}** |
              | ‚ùå **Failed** | **${FAILED_COUNT}** |
              | üü† **Cancelled** | **${CANCELLED_COUNT}** |
              | ‚è≠Ô∏è **Skipped** | **${SKIPPED_COUNT}** |
              ${PENDING_COUNT > 0 ? `| ‚è≥ **Running** | **${PENDING_COUNT}** |` : ''}
              
              ---
              
              ### üìã **Detailed Check Results**
              
              ${failedList}${cancelledList}${pendingList}${successList}${skippedList}
              
              ---
              
              ### üöÄ **Quick Actions**
              
              <table>
              <tr>
              <td align="center">
              <a href="https://github.com/${{ github.repository }}/pull/${PR_NUMBER}/checks">
              üîç<br/>
              <strong>View All Checks</strong>
              </a><br/>
              <sub>See detailed workflow results and logs</sub>
              </td>
              <td align="center">
              <a href="https://github.com/${{ github.repository }}/commit/${pr_json.head_sha}">
              üìù<br/>
              <strong>View Commit</strong>
              </a><br/>
              <sub>Review your changes</sub>
              </td>
              <td align="center">
              <a href="${PR_URL}">
              üîÑ<br/>
              <strong>View PR</strong>
              </a><br/>
              <sub>Go to PR overview</sub>
              </td>
              <td align="center">
              <a href="${PR_URL}/files">
              üìä<br/>
              <strong>Files Changed</strong>
              </a><br/>
              <sub>Review modified files</sub>
              </td>
              </tr>
              </table>
              
              ---
              
              <div align="center">
              
              **ü§ñ Automated notification from ZenDNN Build System**  
              *üìß This replaces email notification (SMTP blocked by AMD enterprise)*
              
              </div>
              
              <!-- PR-${PR_NUMBER}-${HEAD_SHA} -->`;
              
                            // Create comment on PR
                            await github.rest.issues.createComment({
                              owner: context.repo.owner,
                              repo: context.repo.repo,
                              issue_number: PR_NUMBER,
                              body: commentBody
                            });
              
                            console.log(`‚úÖ Enhanced PR comment sent successfully to @${PR_AUTHOR_RAW}`);
                            console.log(`üìä Summary: ${SUCCESS_COUNT} passed, ${FAILED_COUNT} failed, ${CANCELLED_COUNT} cancelled, ${SKIPPED_COUNT} skipped`);
                            console.log(`üìß This replaces the email that would have been sent to ${PR_AUTHOR_RAW}@amd.com`);
                            
                          } catch (error) {
                            console.log(`‚ùå Failed to create enhanced PR comment: ${error.message}`);
                            
                            // Simple fallback comment
                            try {
                              const pr_json = JSON.parse(`${{ steps.pr_info.outputs.result }}`);
                              const checks_json = JSON.parse(`${{ steps.monitor_checks.outputs.result }}`);
                              
                              const simpleFallback = `## üîî ZenDNN PR #${pr_json.number} - Workflow Completed
              
              **Hey @${pr_json.author}!** Your PR workflow has finished.
              
              **Results:** ${(checks_json.checks || []).filter(c => c.status === 'success').length} passed, ${(checks_json.checks || []).filter(c => c.status === 'failure').length} failed
              
              [üìä View All Results ‚Üí](https://github.com/${{ github.repository }}/pull/${pr_json.number}/checks)
              
              ü§ñ *ZenDNN Build System*`;
              
                              await github.rest.issues.createComment({
                                owner: context.repo.owner,
                                repo: context.repo.repo,
                                issue_number: pr_json.number,
                                body: simpleFallback
                              });
                              
                              console.log(`‚úÖ Simple fallback comment sent to @${pr_json.author}`);
                            } catch (fallbackError) {
                              console.log(`‚ùå Both enhanced and fallback comments failed: ${fallbackError.message}`);
                            }
                          }
              
                          console.log(`üéâ Notification process completed for PR #${PR_NUMBER}`);
              
