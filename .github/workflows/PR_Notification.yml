# ******************************************************************************
# Copyright (c) 2025 Advanced Micro Devices, Inc.
# All rights reserved.
# ******************************************************************************
name: PR Status Notification (Main Branch)
on:
  pull_request:
    branches: [main]
    types: [opened, reopened, synchronize]

permissions:
  checks: read
  pull-requests: read
  contents: read
  actions: read

jobs:
  notify_teams:
    runs-on: amd-zenai-arc-xsmall-dind
    timeout-minutes: 120
    if: github.actor != 'github-actions[bot]'
    
    steps:
      - name: Get PR info
        id: pr_info
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            
            return {
              number: pr.number,
              title: pr.title || '',
              url: pr.html_url || '',
              head_sha: pr.head.sha,
              author: pr.user?.login || '',
              base_ref: pr.base?.ref || '',
              head_ref: pr.head?.ref || '',
              created_at: pr.created_at
            };

      - name: Find Triggered External Workflows
        id: find_external
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ZIAIE_PAT }}
          script: |
            const pr = JSON.parse(`${{ steps.pr_info.outputs.result }}`);
            
            console.log(`üéØ Looking for workflows triggered by PR #${pr.number}`);
            console.log(`Expected: 3 external workflows (2 in PyTorch + 1 in TensorFlow)`);
            console.log(`üîë Using ZIAIE_PAT for cross-repo access`);
            
            try {
              const user = await github.rest.users.getAuthenticated();
              console.log(`‚úÖ Authenticated as: ${user.data.login}`);
              
              console.log('‚è≥ Waiting 6 minutes for workflow triggers and job initialization...');
              await new Promise(resolve => setTimeout(resolve, 360000));
              
              const matchedWorkflows = [];
              
              const externalRepos = [
                {
                  owner: 'AMD-Zenai',
                  repo: 'ZenDNN_PyTorch_Plugin',
                  name: 'ZenDNN PyTorch Plugin',
                  expectedTriggers: ['zendnn-pr', 'zendnn-zentorch-zendnnl-pr']
                },
                {
                  owner: 'AMD-Zenai', 
                  repo: 'ZenDNN_TensorFlow_Plugin',
                  name: 'ZenDNN TensorFlow Plugin',
                  expectedTriggers: ['zendnn-pr']
                }
              ];
              
              for (const repoInfo of externalRepos) {
                console.log(`\nüîç Checking ${repoInfo.name} for PR #${pr.number}...`);
                
                try {
                  const repoResp = await github.rest.repos.get({
                    owner: repoInfo.owner,
                    repo: repoInfo.repo
                  });
                  console.log(`‚úÖ Repository accessible: ${repoResp.data.full_name}`);
                  
                  const response = await github.rest.actions.listWorkflowRunsForRepo({
                    owner: repoInfo.owner,
                    repo: repoInfo.repo,
                    per_page: 100
                  });
                  
                  const dispatchRuns = response.data.workflow_runs.filter(run => 
                    run.event === 'repository_dispatch'
                  );
                  
                  // ‚úÖ ENHANCED: Look for runs triggered after this PR was created
                  const prCreatedTime = new Date(pr.created_at);
                  const recentRuns = dispatchRuns.filter(run => {
                    const runTime = new Date(run.created_at);
                    const timeDiff = (runTime - prCreatedTime) / (1000 * 60); // minutes
                    return timeDiff >= -5 && timeDiff <= 120; // 5 min before PR to 2 hours after
                  });
                  
                  console.log(`  Found ${recentRuns.length} potential runs since PR creation`);
                  
                  // ‚úÖ CRITICAL: Track found workflows to avoid duplicates
                  const foundWorkflowTypes = new Set();
                  
                  for (const run of recentRuns) {
                    if (foundWorkflowTypes.size >= repoInfo.expectedTriggers.length) {
                      console.log(`  ‚úÖ Already found all expected workflows for ${repoInfo.name}`);
                      break;
                    }
                    
                    const age = Math.round((Date.now() - new Date(run.created_at)) / (1000 * 60));
                    const runTitle = run.display_title || run.name || '';
                    
                    console.log(`    üîç Checking run: "${runTitle}" (${age}m ago)`);
                    
                    let foundMatch = false;
                    let triggerType = 'Unknown';
                    let matchMethod = '';
                    
                    try {
                      // METHOD 1: Check workflow title for PR patterns
                      const titlePatterns = [
                        new RegExp(`#${pr.number}\\b`, 'i'),
                        new RegExp(`PR\\s*${pr.number}`, 'i'),
                        new RegExp(`pull\\s*${pr.number}`, 'i')
                      ];
                      
                      const titleMatch = titlePatterns.some(pattern => 
                        pattern.test(runTitle) || pattern.test(run.name || '')
                      );
                      
                      if (titleMatch) {
                        console.log(`      ‚úÖ FOUND PR #${pr.number} in workflow title!`);
                        foundMatch = true;
                        matchMethod = 'title';
                      }
                      
                      // METHOD 2: Check job logs for PR reference
                      if (!foundMatch) {
                        console.log(`      üîç Checking jobs for PR reference...`);
                        
                        const jobsResp = await github.rest.actions.listJobsForWorkflowRun({
                          owner: repoInfo.owner,
                          repo: repoInfo.repo,
                          run_id: run.id
                        });
                        
                        const activeJobs = jobsResp.data.jobs.filter(job => 
                          job.status !== 'queued' && job.status !== 'waiting'
                        );
                        
                        for (const job of activeJobs.slice(0, 2)) {
                          if (foundMatch) break;
                          
                          try {
                            if (['in_progress', 'completed'].includes(job.status)) {
                              const logsResp = await github.rest.actions.downloadJobLogsForWorkflowRun({
                                owner: repoInfo.owner,
                                repo: repoInfo.repo,
                                job_id: job.id
                              });
                              
                              const logsText = logsResp.data.toString();
                              
                              // ‚úÖ ENHANCED: More specific PR patterns
                              const prPatterns = [
                                `PR Number: #${pr.number}`,
                                `zendnn_pr_number.*${pr.number}`,
                                `https://github.com/AMD-Zenai/ZenDNN/pull/${pr.number}`,
                                `Repository: AMD-Zenai/ZenDNN.*#${pr.number}`
                              ];
                              
                              const matchedPattern = prPatterns.find(pattern => 
                                new RegExp(pattern, 'is').test(logsText)
                              );
                              
                              if (matchedPattern) {
                                console.log(`        ‚úÖ FOUND PR #${pr.number} in logs!`);
                                foundMatch = true;
                                matchMethod = 'logs';
                                break;
                              }
                            }
                          } catch (logError) {
                            console.log(`        ‚è≥ Logs not available for job ${job.id}`);
                          }
                        }
                      }
                      
                      // METHOD 3: Smart timing + title pattern for very recent runs
                      if (!foundMatch && age <= 15) {
                        const expectedTitles = repoInfo.expectedTriggers;
                        const matchesExpectedTitle = expectedTitles.some(expected => 
                          runTitle.toLowerCase().includes(expected.toLowerCase())
                        );
                        
                        if (matchesExpectedTitle) {
                          console.log(`      üéØ SMART MATCH: Recent run with expected trigger pattern`);
                          foundMatch = true;
                          matchMethod = 'smart-timing';
                        }
                      }
                      
                      if (foundMatch) {
                        // ‚úÖ DETERMINE TRIGGER TYPE and avoid duplicates
                        if (runTitle.toLowerCase().includes('zentorch-zendnnl') || 
                            runTitle.toLowerCase().includes('zendnnl')) {
                          triggerType = 'ZenTorch ZenDNNL';
                          
                          if (foundWorkflowTypes.has('zentorch-zendnnl')) {
                            console.log(`      ‚ö†Ô∏è Already found ZenTorch ZenDNNL workflow, skipping duplicate`);
                            continue;
                          }
                          foundWorkflowTypes.add('zentorch-zendnnl');
                          
                        } else if (repoInfo.repo === 'ZenDNN_PyTorch_Plugin' && 
                                 runTitle.toLowerCase().includes('zendnn-pr')) {
                          triggerType = 'ZenDNN PyTorch';
                          
                          if (foundWorkflowTypes.has('pytorch')) {
                            console.log(`      ‚ö†Ô∏è Already found PyTorch workflow, skipping duplicate`);
                            continue;
                          }
                          foundWorkflowTypes.add('pytorch');
                          
                        } else if (repoInfo.repo === 'ZenDNN_TensorFlow_Plugin') {
                          triggerType = 'ZenDNN TensorFlow';
                          
                          if (foundWorkflowTypes.has('tensorflow')) {
                            console.log(`      ‚ö†Ô∏è Already found TensorFlow workflow, skipping duplicate`);
                            continue;
                          }
                          foundWorkflowTypes.add('tensorflow');
                        } else {
                          console.log(`      ‚ùå Could not determine trigger type for ${runTitle}`);
                          continue;
                        }
                        
                        console.log(`      üéØ UNIQUE MATCH: ${triggerType} (method: ${matchMethod})`);
                        
                        matchedWorkflows.push({
                          id: run.id,
                          name: `${repoInfo.name} (${triggerType})`,
                          status: run.conclusion || run.status,
                          url: run.html_url,
                          repository: `${repoInfo.owner}/${repoInfo.repo}`,
                          workflow_name: runTitle,
                          trigger_type: triggerType,
                          match_method: matchMethod,
                          age_minutes: age
                        });
                      }
                      
                    } catch (runError) {
                      console.log(`      ‚ùå Error checking run ${run.id}: ${runError.message}`);
                    }
                  }
                  
                  console.log(`  üìä Found ${foundWorkflowTypes.size} unique workflows for ${repoInfo.name}`);
                  
                } catch (repoError) {
                  console.log(`‚ùå Error accessing ${repoInfo.name}: ${repoError.message}`);
                }
              }
              
              console.log(`\nüéØ FINAL RESULT: Found ${matchedWorkflows.length}/3 unique workflows for PR #${pr.number}`);
              if (matchedWorkflows.length > 0) {
                console.log(`‚úÖ UNIQUE MATCHED WORKFLOWS:`);
                matchedWorkflows.forEach(wf => {
                  console.log(`  ‚úÖ ${wf.name}: ${wf.status} (${wf.match_method})`);
                });
              }
              
              return {
                found: matchedWorkflows.length > 0,
                external_workflows: matchedWorkflows,
                expected_count: 3,
                found_count: matchedWorkflows.length
              };
              
            } catch (error) {
              console.log(`‚ùå Error: ${error.message}`);
              return { 
                found: false, 
                external_workflows: [],
                expected_count: 3,
                found_count: 0
              };
            }

      - name: Wait for ALL workflows and checks to complete
        id: wait_for_completion
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ZIAIE_PAT }}
          script: |
            const pr = JSON.parse(`${{ steps.pr_info.outputs.result }}`);
            
            // Safe parsing of external workflows result
            let externalResult = { found: false, external_workflows: [] };
            try {
              const externalOutput = `${{ steps.find_external.outputs.result || '{}' }}`;
              externalResult = externalOutput ? JSON.parse(externalOutput) : { found: false, external_workflows: [] };
            } catch (error) {
              console.log(`Could not parse external result: ${error.message}`);
              externalResult = { found: false, external_workflows: [] };
            }
            
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const ref = pr.head_sha;

            console.log(`üîç Monitoring ALL workflows and checks for PR #${pr.number}, commit: ${ref}`);
            console.log(`External workflows found: ${externalResult.external_workflows.length}`);
            
            const checkAllWorkflowsAndChecks = async () => {
              try {
                const importantWorkflows = [
                  'jira-id-check',
                  'license-header-check', 
                  'zendnn_build_pr',
                  'trigger_pytorch_plugin',
                  'trigger_tensorflow_plugin',
                  'trigger-zentorch-zendnnl',
                  'check_status',
                  'check jira id',
                  'verify jira id',
                  'check license headers',
                  'verify license headers'
                ];

                console.log(`üìä Checking ALL workflows and checks for commit: ${ref.substring(0, 7)}`);

                // ‚úÖ Get ALL LOCAL workflow runs for this commit
                const workflowResp = await github.rest.actions.listWorkflowRunsForRepo({
                  owner,
                  repo,
                  head_sha: ref,
                  per_page: 100
                });
                
                const workflows = (workflowResp.data.workflow_runs || [])
                  .filter(run => {
                    const name = run.name.toLowerCase();
                    const isImportant = importantWorkflows.some(important => 
                      name.includes(important.toLowerCase())
                    );
                    const isSelf = run.id === context.runId;
                    const isNotification = name.includes('notification') || 
                                         name.includes('notify') ||
                                         name.includes('pr status');
                    
                    return !isSelf && !isNotification && isImportant;
                  });

                // ‚úÖ Get ALL LOCAL check runs for this commit
                const checkResp = await github.rest.checks.listForRef({
                  owner,
                  repo,
                  ref,
                  per_page: 100
                });
                
                const checks = (checkResp.data.check_runs || [])
                  .filter(check => {
                    const name = check.name.toLowerCase();
                    const isImportant = importantWorkflows.some(important => 
                      name.includes(important.toLowerCase())
                    );
                    const isNotification = name.includes('notify') || 
                                         name.includes('notification') ||
                                         name.includes('pr status');
                    
                    return !isNotification && isImportant;
                  });

                // ‚úÖ ENHANCED: Get ALL status checks AND commit status for this commit
                const statusResp = await github.rest.repos.getCombinedStatusForRef({
                  owner,
                  repo,
                  ref
                });

                const statuses = statusResp.data.statuses || [];

                // ‚úÖ ENHANCED: Also get check suites and their check runs
                const checkSuitesResp = await github.rest.checks.listSuitesForRef({
                  owner,
                  repo,
                  ref,
                  per_page: 100
                });

                const allCheckRuns = [];
                for (const suite of (checkSuitesResp.data.check_suites || [])) {
                  try {
                    const suiteRunsResp = await github.rest.checks.listForSuite({
                      owner,
                      repo,
                      check_suite_id: suite.id,
                      per_page: 100
                    });
                    allCheckRuns.push(...(suiteRunsResp.data.check_runs || []));
                  } catch (suiteError) {
                    console.log(`Could not get check runs for suite ${suite.id}: ${suiteError.message}`);
                  }
                }

                // Combine checks and check runs (remove duplicates)
                const allChecks = [...checks];
                allCheckRuns.forEach(checkRun => {
                  if (!allChecks.find(check => check.id === checkRun.id)) {
                    allChecks.push(checkRun);
                  }
                });

                // Combine all LOCAL workflow information
                const allRuns = [];
                
                // Add ALL local workflows
                workflows.forEach(run => {
                  allRuns.push({
                    id: run.id,
                    name: run.name,
                    status: run.conclusion || run.status,
                    url: run.html_url,
                    type: 'local_workflow_run',
                    repository: `${owner}/${repo}`
                  });
                });

                // Add ALL local checks (avoid duplicates)
                allChecks.forEach(check => {
                  if (!allRuns.find(run => run.name === check.name)) {
                    allRuns.push({
                      id: check.id,
                      name: check.name,
                      status: check.conclusion || check.status,
                      url: check.html_url,
                      type: 'local_check_run',
                      repository: `${owner}/${repo}`
                    });
                  }
                });

                // Add ALL status checks (avoid duplicates)
                statuses.forEach(status => {
                  if (!allRuns.find(run => run.name === status.context)) {
                    allRuns.push({
                      id: status.id,
                      name: status.context,
                      status: status.state,
                      url: status.target_url || status.url,
                      type: 'local_status_check',
                      repository: `${owner}/${repo}`
                    });
                  }
                });

                // Add MATCHED external workflows and update their status
                for (const extWorkflow of externalResult.external_workflows) {
                  try {
                    // Get updated status for external workflow
                    const [extOwner, extRepo] = extWorkflow.repository.split('/');
                    const externalResp = await github.rest.actions.getWorkflowRun({
                      owner: extOwner,
                      repo: extRepo,
                      run_id: extWorkflow.id
                    });
                    
                    allRuns.push({
                      id: externalResp.data.id,
                      name: `üåê ${extWorkflow.name}`,
                      status: externalResp.data.conclusion || externalResp.data.status,
                      url: externalResp.data.html_url,
                      type: 'external_workflow_run',
                      repository: extWorkflow.repository
                    });
                    
                  } catch (extError) {
                    console.log(`‚ùå Could not update external workflow ${extWorkflow.id}: ${extError.message}`);
                    // Add with last known status
                    allRuns.push({
                      id: extWorkflow.id,
                      name: `üåê ${extWorkflow.name}`,
                      status: extWorkflow.status || 'unknown',
                      url: extWorkflow.url,
                      type: 'external_workflow_run',
                      repository: extWorkflow.repository
                    });
                  }
                }

                // ‚úÖ ENHANCED: Include ALL possible status states
                const running = allRuns.filter(r => 
                  ['in_progress', 'queued', 'pending', 'waiting', 'requested', 'action_required'].includes(r.status)
                );
                
                const completed = allRuns.filter(r => 
                  ['success', 'failure', 'cancelled', 'skipped', 'error', 'neutral', 'timed_out'].includes(r.status)
                );

                // Detailed status logging
                console.log(`\nüìã COMPLETE STATUS SUMMARY:`);
                console.log(`Total workflows/checks: ${allRuns.length}`);
                console.log(`  - Workflows: ${workflows.length}`);
                console.log(`  - Check runs: ${allChecks.length}`);
                console.log(`  - Status checks: ${statuses.length}`);
                console.log(`  - External workflows: ${externalResult.external_workflows.length}`);
                console.log(`Completed: ${completed.length}`);
                console.log(`Still running: ${running.length}`);

                console.log(`\nüìä ALL WORKFLOWS AND CHECKS (LOCAL + EXTERNAL):`);
                allRuns.forEach(run => {
                  const statusIcon = run.status === 'success' ? '‚úÖ' : 
                                    run.status === 'failure' ? '‚ùå' : 
                                    ['in_progress', 'pending', 'queued'].includes(run.status) ? '‚è≥' : 
                                    run.status === 'cancelled' ? 'üü†' :
                                    run.status === 'skipped' ? '‚è≠Ô∏è' : 
                                    run.status === 'neutral' ? '‚ö™' :
                                    run.status === 'error' ? 'üî¥' :
                                    run.status === 'timed_out' ? '‚è∞' : 'üîÑ';
                  
                  const typeLabel = run.type.includes('external') ? ` [${run.repository}]` : 
                                   run.type.includes('status') ? ' [status]' :
                                   run.type.includes('check') ? ' [check]' : ' [workflow]';
                  console.log(`  ${statusIcon} ${run.name}${typeLabel}: ${run.status.toUpperCase()}`);
                });
                
                if (running.length > 0) {
                  console.log(`\n‚è≥ STILL WAITING FOR:`);
                  running.forEach(r => {
                    console.log(`   üîÑ ${r.name}: ${r.status}`);
                  });
                }

                const allComplete = running.length === 0 && allRuns.length > 0;
                
                if (allComplete) {
                  console.log(`\nüéâ ALL ${allRuns.length} WORKFLOWS AND CHECKS COMPLETED!`);
                } else {
                  console.log(`\n‚è≥ Waiting for ${running.length} workflow(s)/check(s) to complete...`);
                }

                return {
                  all_complete: allComplete,
                  workflows: allRuns,
                  running_count: running.length,
                  completed_count: completed.length,
                  total_count: allRuns.length,
                  external_count: externalResult.external_workflows.length,
                  workflow_count: workflows.length,
                  check_count: allChecks.length,
                  status_count: statuses.length,
                  currently_running: running.map(r => r.name)
                };
                
              } catch (error) {
                console.log(`‚ùå Error checking workflows and checks: ${error.message}`);
                return { 
                  all_complete: false,
                  workflows: [], 
                  error: error.message,
                  external_count: 0
                };
              }
            };

            console.log('‚è≥ Waiting 7 minutes for all workflows and checks to initialize...');
            await new Promise(resolve => setTimeout(resolve, 420000));  // 7 minutes

            let result = await checkAllWorkflowsAndChecks();
            let attempts = 0;
            const maxAttempts = 60;  // 60 minutes max wait for main branch
            
            console.log(`\nüîç INITIAL CHECK RESULTS:`);
            console.log(`Found ${result.total_count} workflows/checks (${result.external_count} external), ${result.running_count} still running`);

            while (!result.all_complete && attempts < maxAttempts) {
              attempts++;
              console.log(`\n‚è≥ ATTEMPT ${attempts}/${maxAttempts}:`);
              console.log(`   Still waiting for: ${result.currently_running?.join(', ') || 'unknown'}`);
              
              await new Promise(resolve => setTimeout(resolve, 60000));  // Wait 1 minute
              result = await checkAllWorkflowsAndChecks();
            }

            if (!result.all_complete) {
              console.log(`\n‚è∞ TIMEOUT after ${attempts} attempts (${maxAttempts} minutes).`);
              console.log(`‚ö†Ô∏è  Still running: ${result.currently_running?.join(', ') || 'none'}`);
              console.log(`‚ùå FORCED COMPLETION - Some workflows may still be running!`);
              
              result.all_complete = true;
              result.timeout_reason = `Timeout after ${maxAttempts} minutes`;
              result.forced_completion = true;
            } else {
              console.log(`\nüéâ SUCCESS: All workflows and checks completed after ${attempts} attempts! (${attempts} minutes)`);
              result.forced_completion = false;
            }

            return result;

      - name: Send Complete Status Notification
        env:
          TEAMS_WEBHOOK_URL: ${{ secrets.TEAMS_WEBHOOK_URL }}
        run: |
          pr_json='${{ steps.pr_info.outputs.result }}'
          completion_json='${{ steps.wait_for_completion.outputs.result }}'

          PR_NUMBER=$(echo "$pr_json" | jq -r '.number // "N/A"')
          PR_TITLE=$(echo "$pr_json" | jq -r '.title // "N/A"' | sed 's/"/\\"/g' | sed "s/'/\\'/g")
          PR_URL=$(echo "$pr_json" | jq -r '.url // "N/A"')
          PR_AUTHOR=$(echo "$pr_json" | jq -r '.author // "N/A"')
          HEAD_SHA=$(echo "$pr_json" | jq -r '.head_sha // "N/A"')
          SHORT_SHA=$(echo "$HEAD_SHA" | cut -c1-7)

          # Safe parsing with defaults
          ALL_COMPLETE=$(echo "$completion_json" | jq -r '.all_complete // false')
          TOTAL_COUNT=$(echo "$completion_json" | jq -r '.total_count // 0')
          EXTERNAL_COUNT=$(echo "$completion_json" | jq -r '.external_count // 0')
          WORKFLOW_COUNT=$(echo "$completion_json" | jq -r '.workflow_count // 0')
          CHECK_COUNT=$(echo "$completion_json" | jq -r '.check_count // 0')
          STATUS_COUNT=$(echo "$completion_json" | jq -r '.status_count // 0')
          RUNNING_COUNT=$(echo "$completion_json" | jq -r '.running_count // 0')
          FORCED_COMPLETION=$(echo "$completion_json" | jq -r '.forced_completion // false')

          WORKFLOWS=$(echo "$completion_json" | jq -c '.workflows // []')
          
          # ‚úÖ ENHANCED: Count ALL possible status types
          SUCCESS_COUNT=$(echo "$WORKFLOWS" | jq '[.[] | select(.status == "success")] | length')
          FAILED_COUNT=$(echo "$WORKFLOWS" | jq '[.[] | select(.status == "failure")] | length')
          CANCELLED_COUNT=$(echo "$WORKFLOWS" | jq '[.[] | select(.status == "cancelled")] | length')
          SKIPPED_COUNT=$(echo "$WORKFLOWS" | jq '[.[] | select(.status == "skipped")] | length')
          NEUTRAL_COUNT=$(echo "$WORKFLOWS" | jq '[.[] | select(.status == "neutral")] | length')
          ERROR_COUNT=$(echo "$WORKFLOWS" | jq '[.[] | select(.status == "error")] | length')
          TIMED_OUT_COUNT=$(echo "$WORKFLOWS" | jq '[.[] | select(.status == "timed_out")] | length')
          PENDING_COUNT=$(echo "$WORKFLOWS" | jq '[.[] | select(.status == "pending" or .status == "in_progress" or .status == "queued" or .status == "waiting")] | length')

          echo "‚úÖ Workflow monitoring completed! Building notification..."
          echo "Total: $TOTAL_COUNT (Workflows: $WORKFLOW_COUNT, Checks: $CHECK_COUNT, Status: $STATUS_COUNT, External: $EXTERNAL_COUNT)"
          echo "Results: Success: $SUCCESS_COUNT, Failed: $FAILED_COUNT, Cancelled: $CANCELLED_COUNT, Skipped: $SKIPPED_COUNT, Neutral: $NEUTRAL_COUNT"

          WORKFLOW_TEXTBLOCKS=""
          if [ "$TOTAL_COUNT" -gt 0 ]; then
             echo "Building all workflows and checks with colored status text..."
             WORKFLOW_COUNT_TOTAL=$(echo "$WORKFLOWS" | jq 'length')
             for i in $(seq 0 $((WORKFLOW_COUNT_TOTAL - 1))); do
               NAME=$(echo "$WORKFLOWS" | jq -r ".[$i].name")
               STATUS=$(echo "$WORKFLOWS" | jq -r ".[$i].status | ascii_upcase")
               URL=$(echo "$WORKFLOWS" | jq -r ".[$i].url")
               REPO=$(echo "$WORKFLOWS" | jq -r ".[$i].repository // \"\"")
               TYPE=$(echo "$WORKFLOWS" | jq -r ".[$i].type // \"\"")
               
               # Escape quotes for JSON
               NAME_SAFE=$(echo "$NAME" | sed 's/"/\\"/g')
               
               # ‚úÖ ENHANCED: Color coding for ALL status types
               case "$STATUS" in
                 "SUCCESS")
                   STATUS_COLOR="Good"
                   STATUS_WEIGHT="Bolder"
                   ;;
                 "FAILURE")
                   STATUS_COLOR="Attention"
                   STATUS_WEIGHT="Bolder"
                   ;;
                 "CANCELLED")
                   STATUS_COLOR="Warning"
                   STATUS_WEIGHT="Bolder"
                   ;;
                 "SKIPPED")
                   STATUS_COLOR="Accent"
                   STATUS_WEIGHT="Bolder"
                   ;;
                 "NEUTRAL")
                   STATUS_COLOR="Default"
                   STATUS_WEIGHT="Bolder"
                   ;;
                 "ERROR")
                   STATUS_COLOR="Attention"
                   STATUS_WEIGHT="Bolder"
                   ;;
                 "TIMED_OUT")
                   STATUS_COLOR="Warning"
                   STATUS_WEIGHT="Bolder"
                   ;;
                 "IN_PROGRESS"|"PENDING"|"QUEUED"|"WAITING")
                   STATUS_COLOR="Default"
                   STATUS_WEIGHT="Normal"
                   ;;
                 *)
                   STATUS_COLOR="Default"
                   STATUS_WEIGHT="Normal"
                   ;;
               esac
               
               # Show type and repository information
               if [[ "$TYPE" == *"external"* ]] && [ "$REPO" != "$GITHUB_REPOSITORY" ] && [ -n "$REPO" ] && [ "$REPO" != "null" ]; then
                 REPO_TEXT=" [$REPO]"
               elif [[ "$TYPE" == *"status"* ]]; then
                 REPO_TEXT=" [status]"
               elif [[ "$TYPE" == *"check"* ]]; then
                 REPO_TEXT=" [check]"
               else
                 REPO_TEXT=""
               fi
               
               # Create RichTextBlock with colored status
               COMBINED_BLOCK='{
                 "type": "RichTextBlock",
                 "inlines": [
                   {
                     "type": "TextRun",
                     "text": "‚Ä¢ "
                   },
                   {
                     "type": "TextRun",
                     "text": "'$NAME_SAFE'",
                     "selectAction": {
                       "type": "Action.OpenUrl",
                       "url": "'$URL'"
                     }
                   },
                   {
                     "type": "TextRun",
                     "text": " - "
                   },
                   {
                     "type": "TextRun",
                     "text": "'$STATUS'",
                     "color": "'$STATUS_COLOR'",
                     "weight": "'$STATUS_WEIGHT'",
                     "size": "Medium"
                   },
                   {
                     "type": "TextRun",
                     "text": "'$REPO_TEXT'",
                     "color": "Dark",
                     "size": "Small"
                   }
                 ],
                 "spacing": "None"
               }'
               
               if [ -z "$WORKFLOW_TEXTBLOCKS" ]; then
                 WORKFLOW_TEXTBLOCKS="$COMBINED_BLOCK"
               else
                 WORKFLOW_TEXTBLOCKS="$WORKFLOW_TEXTBLOCKS,$COMBINED_BLOCK"
               fi
             done
           else
            WORKFLOW_TEXTBLOCKS='{
              "type": "TextBlock",
              "text": "‚Ä¢ No workflows or checks found",
              "wrap": true,
              "size": "Small",
              "color": "Default"
              }'
            fi

          # Determine overall status
          if [ "$FAILED_COUNT" -gt 0 ] || [ "$ERROR_COUNT" -gt 0 ]; then
            ICON="üî¥"
            STATUS_TEXT="‚ùå SOME CHECKS FAILED"
            COLOR="Attention"
          elif [ "$CANCELLED_COUNT" -gt 0 ]; then
            ICON="üü†"
            STATUS_TEXT="üü† SOME CHECKS CANCELLED"
            COLOR="Warning"
          elif [ "$TIMED_OUT_COUNT" -gt 0 ]; then
            ICON="‚è∞"
            STATUS_TEXT="‚è∞ SOME CHECKS TIMED OUT"
            COLOR="Warning"
          elif [ "$FORCED_COMPLETION" = "true" ]; then
            ICON="üü°"
            STATUS_TEXT="‚è∞ TIMEOUT - SOME CHECKS MAY STILL BE RUNNING"
            COLOR="Warning"
          elif [ "$PENDING_COUNT" -gt 0 ]; then
            ICON="üü°"
            STATUS_TEXT="‚è≥ SOME CHECKS STILL RUNNING"
            COLOR="Default"
          elif [ "$ALL_COMPLETE" = "true" ] && [ "$SUCCESS_COUNT" -gt 0 ] && [ "$FAILED_COUNT" -eq 0 ] && [ "$ERROR_COUNT" -eq 0 ]; then
            ICON="üü¢"
            STATUS_TEXT="‚úÖ ALL CHECKS PASSED"
            COLOR="Good"
          elif [ "$ALL_COMPLETE" = "true" ] && [ "$TOTAL_COUNT" -eq 0 ]; then
            ICON="‚ö™"
            STATUS_TEXT="‚ö™ NO WORKFLOWS OR CHECKS FOUND"
            COLOR="Default"
          else
            ICON="üü°"
            STATUS_TEXT="‚ö†Ô∏è MIXED RESULTS"
            COLOR="Warning"
          fi

          # Completion status
          LOCAL_COUNT=$((TOTAL_COUNT - EXTERNAL_COUNT))
          if [ "$FORCED_COMPLETION" = "true" ]; then
            COMPLETION_TEXT="‚è∞ Timeout reached - $RUNNING_COUNT workflows may still be running"
          elif [ "$ALL_COMPLETE" = "true" ]; then
            COMPLETION_TEXT="‚úÖ All $TOTAL_COUNT workflows and checks completed ($LOCAL_COUNT local + $EXTERNAL_COUNT external)"
          else
            COMPLETION_TEXT="‚è∞ $RUNNING_COUNT of $TOTAL_COUNT workflows still running"
          fi

          # Escape for JSON
          TITLE_SAFE="$ICON PR #$PR_NUMBER (Main) ‚Äî $PR_TITLE"

          echo "üì§ Sending complete Teams notification..."

          # Create final status notification
          cat > card.json <<EOF
          {
            "type": "message",
            "attachments": [
              {
                 "contentType": "application/vnd.microsoft.card.adaptive",
                 "content": {
                    "\$schema": "http://adaptivecards.io/schemas/adaptive-card.json",
                    "type": "AdaptiveCard",
                    "version": "1.4",
                    "body": [
                      {
                         "type": "Container",
                         "items": [
                           {
                              "type": "TextBlock",
                              "text": "$TITLE_SAFE",
                              "wrap": true,
                              "weight": "Bolder",
                              "size": "Medium"
                           },
                           {
                              "type": "TextBlock",
                              "text": "$STATUS_TEXT",
                              "wrap": true,
                              "weight": "Bolder",
                              "color": "$COLOR",
                              "size": "Large"
                           },
                           {
                              "type": "FactSet",
                              "facts": [
                                    { "title": "Author:", "value": "$PR_AUTHOR" },
                                    { "title": "Branch:", "value": "main" },
                                    { "title": "Commit:", "value": "$SHORT_SHA" },
                                    { "title": "Status:", "value": "$COMPLETION_TEXT" },
                                    { "title": "Total:", "value": "$TOTAL_COUNT" },
                                    { "title": "üèóÔ∏è Workflows:", "value": "$WORKFLOW_COUNT" },
                                    { "title": "‚úîÔ∏è Checks:", "value": "$CHECK_COUNT" },
                                    { "title": "üìä Status:", "value": "$STATUS_COUNT" },
                                    { "title": "üåê External:", "value": "$EXTERNAL_COUNT" },
                                    { "title": "‚úÖ Passed:", "value": "$SUCCESS_COUNT" },
                                    { "title": "‚ùå Failed:", "value": "$FAILED_COUNT" },
                                    { "title": "üü† Cancelled:", "value": "$CANCELLED_COUNT" },
                                    { "title": "‚è≠Ô∏è Skipped:", "value": "$SKIPPED_COUNT" },
                                    { "title": "‚ö™ Neutral:", "value": "$NEUTRAL_COUNT" },
                                    { "title": "üî¥ Error:", "value": "$ERROR_COUNT" },
                                    { "title": "‚è∞ Timed Out:", "value": "$TIMED_OUT_COUNT" },
                                    { "title": "‚è≥ Running:", "value": "$PENDING_COUNT" }
                               ]
                              },
                              {
                                 "type": "TextBlock",
                                 "text": "**Complete Results (Workflows + Checks + External):**",
                                 "wrap": true,
                                 "weight": "Bolder",
                                 "size": "Small",
                                 "spacing": "Medium"
                              },
                              $WORKFLOW_TEXTBLOCKS
                            ]
                          }
                        ],
                        "actions": [
                          {
                             "type": "Action.OpenUrl",
                             "title": "View PR",
                             "url": "$PR_URL"
                          },
                          {
                             "type": "Action.OpenUrl",
                             "title": "View All Checks",
                             "url": "https://github.com/${{ github.repository }}/pull/$PR_NUMBER/checks"
                          },
                          {
                              "type": "Action.OpenUrl",
                              "title": "View Commit",
                              "url": "https://github.com/${{ github.repository }}/commit/$HEAD_SHA"
                          }
                       ]
                   }
              }
             ]
          }
          EOF
           
           curl -s -H "Content-Type: application/json" \
            -d @card.json \
            "$TEAMS_WEBHOOK_URL" || (echo "‚ùå Failed to send Teams message" && exit 1)
           
           echo "‚úÖ Complete Teams notification sent successfully!"
