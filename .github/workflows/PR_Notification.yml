# ******************************************************************************
# Copyright (c) 2025 Advanced Micro Devices, Inc.
# All rights reserved.
# ******************************************************************************
name: PR Status Notification
on:
  pull_request:
    types: [opened, reopened, synchronize]

permissions:
  checks: read
  pull-requests: read
  contents: read
  actions: read

jobs:
  notify_teams:
    runs-on: amd-zenai-arc-xsmall-dind
    timeout-minutes: 60
    # PREVENT SELF-TRIGGERING
    if: github.actor != 'github-actions[bot]'
    
    steps:
      - name: Get PR info
        id: pr_info
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            
            return {
              number: pr.number,
              title: pr.title || '',
              url: pr.html_url || '',
              head_sha: pr.head.sha,
              author: pr.user?.login || '',
              base_ref: pr.base?.ref || '',
              head_ref: pr.head?.ref || ''
            };

      - name: Wait for ALL workflows to complete
        id: wait_for_completion
        uses: actions/github-script@v7
        with:
          script: |
            const pr = JSON.parse(`\${{ steps.pr_info.outputs.result }}`);
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const ref = pr.head_sha;
            
            console.log(`Monitoring workflows for PR #${pr.number}, commit: ${ref}`);
            
            const checkAllWorkflows = async () => {
              try {
                // Get workflow runs
                const workflowResp = await github.rest.actions.listWorkflowRunsForRepo({
                  owner,
                  repo,
                  head_sha: ref,
                  per_page: 100
                });
                
                // EXCLUDE NOTIFICATION WORKFLOWS
                const workflows = (workflowResp.data.workflow_runs || [])
                  .filter(run => {
                    const name = run.name.toLowerCase();
                    return !name.includes('pr status notification') && 
                           !name.includes('notification') &&
                           run.id !== context.runId;
                  });

                // Get check runs
                const checkResp = await github.rest.checks.listForRef({
                  owner,
                  repo,
                  ref,
                  per_page: 100
                });
                
                const checks = (checkResp.data.check_runs || [])
                  .filter(check => {
                    const name = check.name.toLowerCase();
                    return !name.includes('pr status notification') && 
                           !name.includes('notification');
                  });

                // Combine all workflow information
                const allRuns = [];
                
                // Add workflow runs
                workflows.forEach(run => {
                  allRuns.push({
                    id: run.id,
                    name: run.name,
                    status: run.conclusion || run.status,
                    url: run.html_url,
                    type: 'workflow_run',
                    repository: `${owner}/${repo}`,
                    started_at: run.created_at,
                    updated_at: run.updated_at
                  });
                });

                // Add check runs (avoiding duplicates)
                checks.forEach(check => {
                  if (!allRuns.find(run => run.name === check.name)) {
                    allRuns.push({
                      id: check.id,
                      name: check.name,
                      status: check.conclusion || check.status,
                      url: check.html_url,
                      type: 'check_run',
                      repository: check.repository?.full_name || `${owner}/${repo}`,
                      started_at: check.started_at,
                      updated_at: check.completed_at
                    });
                  }
                });

                // Check completion status
                const running = allRuns.filter(r => 
                  ['in_progress', 'queued', 'pending', 'waiting', 'requested'].includes(r.status)
                );
                
                const completed = allRuns.filter(r => 
                  ['success', 'failure', 'cancelled', 'skipped'].includes(r.status)
                );

                console.log(`Found ${allRuns.length} relevant workflows/checks:`);
                allRuns.forEach(run => {
                  console.log(`  - ${run.name}: ${run.status} (${run.type})`);
                });
                
                console.log(`Running: ${running.length}, Completed: ${completed.length}`);

                return {
                  all_complete: running.length === 0 && allRuns.length > 0,
                  workflows: allRuns,
                  running_count: running.length,
                  completed_count: completed.length,
                  total_count: allRuns.length
                };
              } catch (error) {
                console.log(`Error checking workflows: ${error.message}`);
                return { all_complete: false, workflows: [], error: error.message };
              }
            };

            // Give workflows time to start
            console.log('Waiting 2 minutes for workflows to initialize...');
            await new Promise(resolve => setTimeout(resolve, 120000));

            // Start monitoring
            let result = await checkAllWorkflows();
            let attempts = 0;
            const maxAttempts = 58;
            
            console.log(`Initial check: ${result.total_count} workflows found, ${result.running_count} still running`);

            // Keep checking until all workflows complete
            while (!result.all_complete && attempts < maxAttempts) {
              if (result.total_count === 0) {
                console.log('No workflows found yet, waiting for workflows to start...');
              } else {
                console.log(`Attempt ${attempts + 1}: ${result.running_count}/${result.total_count} workflows still running`);
              }
              
              await new Promise(resolve => setTimeout(resolve, 60000));
              result = await checkAllWorkflows();
              attempts++;
            }

            if (!result.all_complete) {
              console.log(`Timeout reached after ${attempts} attempts. Some workflows may still be running.`);
            } else {
              console.log(`All workflows completed after ${attempts} attempts!`);
            }

            return result;

      - name: Send Final Status Notification
        env:
          ZENDNNL_WEBHOOK_URL: ${{ secrets.ZENDNNL_WEBHOOK_URL }}
        run: |
          pr_json='${{ steps.pr_info.outputs.result }}'
          completion_json='${{ steps.wait_for_completion.outputs.result }}'

          PR_NUMBER=$(echo "$pr_json" | jq -r '.number // "N/A"')
          PR_TITLE=$(echo "$pr_json" | jq -r '.title // "N/A"' | sed 's/"/\\"/g' | sed "s/'/\\'/g")
          PR_URL=$(echo "$pr_json" | jq -r '.url // "N/A"')
          PR_AUTHOR=$(echo "$pr_json" | jq -r '.author // "N/A"')
          HEAD_SHA=$(echo "$pr_json" | jq -r '.head_sha // "N/A"')
          SHORT_SHA=$(echo "$HEAD_SHA" | cut -c1-7)

          ALL_COMPLETE=$(echo "$completion_json" | jq -r '.all_complete // false')
          TOTAL_COUNT=$(echo "$completion_json" | jq -r '.total_count // 0')
          RUNNING_COUNT=$(echo "$completion_json" | jq -r '.running_count // 0')

          WORKFLOWS=$(echo "$completion_json" | jq -c '.workflows // []')
          
          SUCCESS_COUNT=$(echo "$WORKFLOWS" | jq '[.[] | select(.status == "success")] | length')
          FAILED_COUNT=$(echo "$WORKFLOWS" | jq '[.[] | select(.status == "failure")] | length')
          CANCELLED_COUNT=$(echo "$WORKFLOWS" | jq '[.[] | select(.status == "cancelled")] | length')

          WORKFLOW_LIST=$(echo "$WORKFLOWS" | jq -r '.[] | "â€¢ [\(.name)](\(.url)) - **\(.status | ascii_upcase)**"')

          if [ "$FAILED_COUNT" -gt 0 ]; then
            ICON="ðŸ”´"
            STATUS_TEXT="âŒ SOME CHECKS FAILED"
            COLOR="Attention"
          elif [ "$CANCELLED_COUNT" -gt 0 ]; then
            ICON="ðŸŸ "
            STATUS_TEXT="ðŸŸ  SOME CHECKS CANCELLED"
            COLOR="Warning"
          elif [ "$ALL_COMPLETE" = "true" ]; then
            ICON="ðŸŸ¢"
            STATUS_TEXT="âœ… ALL CHECKS PASSED"
            COLOR="Good"
          else
            ICON="ðŸŸ¡"
            STATUS_TEXT="â³ CHECKS INCOMPLETE"
            COLOR="Warning"
          fi

          if [ "$ALL_COMPLETE" = "true" ]; then
            COMPLETION_TEXT="ðŸ All $TOTAL_COUNT workflows completed"
          else
            COMPLETION_TEXT="â³ $RUNNING_COUNT of $TOTAL_COUNT workflows still running"
          fi

          TITLE_SAFE="$ICON  PR #$PR_NUMBER â€” $PR_TITLE"
          WORKFLOW_LIST_SAFE=$(echo "$WORKFLOW_LIST" | sed 's/"/\\"/g')

          # Create final status notification
          cat > card.json <<EOF
          {
            "type": "message",
            "attachments": [
              {
                 "contentType": "application/vnd.microsoft.card.adaptive",
                 "content": {
                    "\$schema": "http://adaptivecards.io/schemas/adaptive-card.json",
                    "type": "AdaptiveCard",
                    "version": "1.4",
                    "body": [
                      {
                         "type": "Container",
                         "items": [
                           {
                              "type": "TextBlock",
                              "text": "$TITLE_SAFE",
                              "wrap": true,
                              "weight": "Bolder",
                              "size": "Medium"
                           },
                           {
                              "type": "TextBlock",
                              "text": "$STATUS_TEXT",
                              "wrap": true,
                              "weight": "Bolder",
                              "color": "$COLOR",
                              "size": "Large"
                           },
                           {
                              "type": "FactSet",
                              "facts": [
                                 { "title": "Author:", "value": "$PR_AUTHOR" },
                                 { "title": "Commit:", "value": "$SHORT_SHA" },
                                 { "title": "Completion:", "value": "$COMPLETION_TEXT" },
                                 { "title": "Total Workflows:", "value": "$TOTAL_WORKFLOWS" },
                                 { "title": "âœ… Passed:", "value": "$SUCCESS_COUNT" },
                                 { "title": "âŒ Failed:", "value": "$FAILED_COUNT" },
                                 { "title": "ðŸŸ  Cancelled:", "value": "$CANCELLED_COUNT" }
                               ]
                              },
                              {
                                 "type": "TextBlock",
                                 "text": "**All Workflow Results:**\\n$WORKFLOW_LIST_SAFE",
                                 "wrap": true,
                                 "size": "Small"
                              }
                            ]
                          }
                        ],
                        "actions": [
                          {
                             "type": "Action.OpenUrl",
                             "title": "View PR",
                             "url": "$PR_URL"
                          },
                          {
                             "type": "Action.OpenUrl",
                             "title": "View All Checks",
                             "url": "https://github.com/${{ github.repository }}/pull/$PR_NUMBER/checks"
                          },
                          {
                              "type": "Action.OpenUrl",
                              "title": "View Commit",
                              "url": "https://github.com/${{ github.repository }}/commit/$HEAD_SHA"
                          }
                       ]
                   }
              }
             ]
          }
          EOF

          curl -s -H "Content-Type: application/json" \
            -d @card.json \
            "$ZENDNNL_WEBHOOK_URL" || (echo "Failed to send Teams message" && exit 1)

         
