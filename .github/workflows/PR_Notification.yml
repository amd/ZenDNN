# ******************************************************************************
# Copyright (c) 2025 Advanced Micro Devices, Inc.
# All rights reserved.
# ******************************************************************************
name: PR Status Notification
on:
  pull_request:
    types: [opened, reopened, synchronize]

permissions:
  checks: read
  pull-requests: read
  contents: read
  actions: read

jobs:
  notify_teams:
    runs-on: amd-zenai-arc-xsmall-dind
    timeout-minutes: 60
    if: github.actor != 'github-actions[bot]'
    
    steps:
      - name: Get PR info
        id: pr_info
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            
            return {
              number: pr.number,
              title: pr.title || '',
              url: pr.html_url || '',
              head_sha: pr.head.sha,
              author: pr.user?.login || '',
              base_ref: pr.base?.ref || '',
              head_ref: pr.head?.ref || ''
            };

      - name: Find Triggered ZenTorch Workflow
        id: find_zentorch
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ZIAIE_PAT }}
          script: |
            const pr = JSON.parse(`${{ steps.pr_info.outputs.result }}`);
            
            console.log(`üîç Looking for ZenTorch workflow for PR #${pr.number}`);
            console.log(`üîë Using ZIAIE_PAT for cross-repo access`);
            
            try {
              // Test access with organization PAT
              const user = await github.rest.users.getAuthenticated();
              console.log(`‚úÖ Authenticated as: ${user.data.login}`);
              
              const repo = await github.rest.repos.get({
                owner: 'AMD-Zenai',
                repo: 'ZenDNN_PyTorch_Plugin'
              });
              console.log(`‚úÖ Repository accessible: ${repo.data.full_name} (${repo.data.visibility})`);
              
              // Wait for trigger to process
              console.log('‚è≥ Waiting 2 minutes for ZenTorch trigger...');
              await new Promise(resolve => setTimeout(resolve, 120000));
              
              // Get recent workflow runs
              const response = await github.rest.actions.listWorkflowRunsForRepo({
                owner: 'AMD-Zenai',
                repo: 'ZenDNN_PyTorch_Plugin',
                per_page: 15
              });
              
              console.log(`üìä Found ${response.data.workflow_runs.length} total workflow runs`);
              
              // Filter for repository_dispatch events
              const dispatchRuns = response.data.workflow_runs.filter(run => 
                run.event === 'repository_dispatch'
              );
              
              console.log(`üéØ Found ${dispatchRuns.length} repository_dispatch runs:`);
              
              dispatchRuns.forEach((run, i) => {
                const age = Math.round((Date.now() - new Date(run.created_at)) / (1000 * 60));
                console.log(`  ${i+1}. Run ${run.id}: "${run.name}" - ${run.status} (${age}m ago)`);
              });
              
              // Look for recent runs (within 20 minutes)
              const recentRuns = dispatchRuns.filter(run => {
                const age = (Date.now() - new Date(run.created_at)) / (1000 * 60);
                return age <= 20;
              });
              
              if (recentRuns.length > 0) {
                const mostRecent = recentRuns[0];
                const age = Math.round((Date.now() - new Date(mostRecent.created_at)) / (1000 * 60));
                
                console.log(`‚úÖ Found recent ZenTorch run: ${mostRecent.id} (${age}m ago)`);
                console.log(`   Name: ${mostRecent.name}`);
                console.log(`   Status: ${mostRecent.conclusion || mostRecent.status}`);
                console.log(`   URL: ${mostRecent.html_url}`);
                
                return {
                  found: true,
                  external_run_id: mostRecent.id,
                  external_run_url: mostRecent.html_url,
                  external_repo: 'AMD-Zenai/ZenDNN_PyTorch_Plugin',
                  external_status: mostRecent.conclusion || mostRecent.status,
                  minutes_ago: age,
                  token_used: 'ZIAIE_PAT'
                };
              } else {
                console.log(`‚ö†Ô∏è No recent repository_dispatch runs found (last 20 minutes)`);
                
                if (dispatchRuns.length > 0) {
                  const latest = dispatchRuns[0];
                  const age = Math.round((Date.now() - new Date(latest.created_at)) / (1000 * 60));
                  console.log(`   Most recent was ${age} minutes ago`);
                }
                
                return { 
                  found: false, 
                  external_run_url: '', 
                  reason: 'no_recent_runs',
                  total_dispatch_runs: dispatchRuns.length,
                  token_used: 'ZIAIE_PAT'
                };
              }
              
            } catch (error) {
              console.log(`‚ùå Error accessing ZenTorch repo: ${error.message} (${error.status})`);
              return { 
                found: false, 
                external_run_url: '', 
                error: error.message,
                token_used: 'ZIAIE_PAT'
              };
            }

      - name: Wait for ALL workflows to complete
        id: wait_for_completion
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ZIAIE_PAT }}
          script: |
            const pr = JSON.parse(`${{ steps.pr_info.outputs.result }}`);
            
            // Safe parsing of ZenTorch result
            let zentorchResult = { found: false };
            try {
              const zentorchOutput = `${{ steps.find_zentorch.outputs.result || '{}' }}`;
              zentorchResult = zentorchOutput ? JSON.parse(zentorchOutput) : { found: false };
            } catch (error) {
              console.log(`Could not parse zentorch result: ${error.message}`);
              zentorchResult = { found: false };
            }
            
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const ref = pr.head_sha;

            console.log(`üîç Monitoring workflows for PR #${pr.number}, commit: ${ref}`);
            console.log(`ZenTorch external workflow found: ${zentorchResult.found}`);
            if (zentorchResult.found) {
              console.log(`ZenTorch URL: ${zentorchResult.external_run_url}`);
            }
            
            const checkAllWorkflows = async () => {
              try {
                // Define ALL important workflows including ZenTorch status check
                const importantWorkflows = [
                  'commit message enforcement',
                  'zendnnl_build_pr', 
                  'check-zentorch-status',    // ‚úÖ CRITICAL - This must complete!
                  'asan-build',
                  'zendnnl_build_push',
                  'check jira id',
                  'verify jira id',
                  'check license headers',
                  'verify license headers', 
                  'trigger-zentorch-zendnnl'
                ];

                console.log(`üìä Checking workflows for commit: ${ref.substring(0, 7)}`);

                // Get workflow runs
                const workflowResp = await github.rest.actions.listWorkflowRunsForRepo({
                  owner,
                  repo,
                  head_sha: ref,
                  per_page: 100
                });
                
                const workflows = (workflowResp.data.workflow_runs || [])
                  .filter(run => {
                    const name = run.name.toLowerCase();
                    const isImportant = importantWorkflows.some(important => 
                      name.includes(important.toLowerCase())
                    );
                    const isSelf = run.id === context.runId;
                    
                    return !isSelf && isImportant;
                  });

                // Get check runs
                const checkResp = await github.rest.checks.listForRef({
                  owner,
                  repo,
                  ref,
                  per_page: 100
                });
                
                const checks = (checkResp.data.check_runs || [])
                  .filter(check => {
                    const name = check.name.toLowerCase();
                    const isImportant = importantWorkflows.some(important => 
                      name.includes(important.toLowerCase())
                    );
                    const isNotification = name.includes('notify') || 
                                         name.includes('notification') ||
                                         name.includes('pr status');  // Exclude this notification workflow
                    
                    return !isNotification && isImportant;
                  });

                // Combine all workflow information
                const allRuns = [];
                
                // Add local workflows
                workflows.forEach(run => {
                  allRuns.push({
                    id: run.id,
                    name: run.name,
                    status: run.conclusion || run.status,
                    url: run.html_url,
                    type: 'workflow_run',
                    repository: `${owner}/${repo}`
                  });
                });

                // Add local checks (avoid duplicates)
                checks.forEach(check => {
                  if (!allRuns.find(run => run.name === check.name)) {
                    allRuns.push({
                      id: check.id,
                      name: check.name,
                      status: check.conclusion || check.status,
                      url: check.html_url,
                      type: 'check_run',
                      repository: `${owner}/${repo}`
                    });
                  }
                });

                // ‚úÖ CRITICAL: Check if ZenTorch status check exists and is monitored
                const zentorchStatusCheck = allRuns.find(run => 
                  run.name.toLowerCase().includes('zentorch') && 
                  run.name.toLowerCase().includes('status')
                );
                
                if (!zentorchStatusCheck) {
                  console.log(`‚ö†Ô∏è  WARNING: ZenTorch status check not found in workflow list!`);
                  console.log(`Looking for any ZenTorch-related checks...`);
                  
                  // Search more broadly for ZenTorch checks
                  const allZentorchChecks = checks.filter(check => 
                    check.name.toLowerCase().includes('zentorch')
                  );
                  
                  if (allZentorchChecks.length > 0) {
                    console.log(`Found ${allZentorchChecks.length} ZenTorch-related checks:`);
                    allZentorchChecks.forEach(check => {
                      console.log(`  - ${check.name}: ${check.conclusion || check.status}`);
                      
                      // Add missing ZenTorch checks
                      if (!allRuns.find(run => run.id === check.id)) {
                        allRuns.push({
                          id: check.id,
                          name: check.name,
                          status: check.conclusion || check.status,
                          url: check.html_url,
                          type: 'check_run',
                          repository: `${owner}/${repo}`
                        });
                      }
                    });
                  }
                }

                // Add external ZenTorch workflow if found
                if (zentorchResult.found && zentorchResult.external_run_id) {
                  console.log(`üì° Adding external ZenTorch workflow to monitoring...`);
                  try {
                    const externalResp = await github.rest.actions.getWorkflowRun({
                      owner: 'AMD-Zenai',
                      repo: 'ZenDNN_PyTorch_Plugin',
                      run_id: zentorchResult.external_run_id
                    });
                    
                    allRuns.push({
                      id: externalResp.data.id,
                      name: `ZenDNN_PyTorch_Plugin: ${externalResp.data.display_title || externalResp.data.name}`,
                      status: externalResp.data.conclusion || externalResp.data.status,
                      url: externalResp.data.html_url,
                      type: 'triggered_workflow_run',
                      repository: 'AMD-Zenai/ZenDNN_PyTorch_Plugin'
                    });
                    
                    console.log(`External ZenTorch status: ${externalResp.data.conclusion || externalResp.data.status}`);
                  } catch (zentorchError) {
                    console.log(`‚ùå Could not get external ZenTorch status: ${zentorchError.message}`);
                  }
                }

                // ‚úÖ SEPARATE RUNNING vs COMPLETED CHECKS
                const running = allRuns.filter(r => 
                  ['in_progress', 'queued', 'pending', 'waiting', 'requested'].includes(r.status)
                );
                
                const completed = allRuns.filter(r => 
                  ['success', 'failure', 'cancelled', 'skipped'].includes(r.status)
                );

                // ‚úÖ DETAILED STATUS LOGGING
                console.log(`\nüìã WORKFLOW STATUS SUMMARY:`);
                console.log(`Total workflows found: ${allRuns.length}`);
                console.log(`Completed: ${completed.length}`);
                console.log(`Still running: ${running.length}`);

                console.log(`\nüìä ALL WORKFLOWS:`);
                allRuns.forEach(run => {
                  const statusIcon = run.status === 'success' ? '‚úÖ' : 
                                    run.status === 'failure' ? '‚ùå' : 
                                    ['in_progress', 'pending', 'queued'].includes(run.status) ? '‚è≥' : 
                                    run.status === 'cancelled' ? 'üü†' :
                                    run.status === 'skipped' ? '‚è≠Ô∏è' : 'üîÑ';
                  
                  console.log(`  ${statusIcon} ${run.name}: ${run.status.toUpperCase()}`);
                });
                
                if (running.length > 0) {
                  console.log(`\n‚è≥ STILL WAITING FOR:`);
                  running.forEach(r => {
                    console.log(`   üîÑ ${r.name}: ${r.status}`);
                  });
                }

                // ‚úÖ CRITICAL: Only complete when NO workflows are running
                const allComplete = running.length === 0 && allRuns.length > 0;
                
                if (allComplete) {
                  console.log(`\nüéâ ALL ${allRuns.length} WORKFLOWS COMPLETED!`);
                } else {
                  console.log(`\n‚è≥ Waiting for ${running.length} workflow(s) to complete...`);
                }

                return {
                  all_complete: allComplete,
                  workflows: allRuns,
                  running_count: running.length,
                  completed_count: completed.length,
                  total_count: allRuns.length,
                  zentorch_included: zentorchResult.found,
                  external_workflow_url: zentorchResult.external_run_url || '',
                  currently_running: running.map(r => r.name)
                };
                
              } catch (error) {
                console.log(`‚ùå Error checking workflows: ${error.message}`);
                return { 
                  all_complete: false,  // ‚úÖ Don't force complete on error
                  workflows: [], 
                  error: error.message,
                  zentorch_included: false
                };
              }
            };

            // ‚úÖ LONGER INITIAL WAIT for workflows to register
            console.log('‚è≥ Waiting 3 minutes for all workflows to initialize...');
            await new Promise(resolve => setTimeout(resolve, 180000));  // 3 minutes

            let result = await checkAllWorkflows();
            let attempts = 0;
            const maxAttempts = 30;  // ‚úÖ Increased to 30 minutes max wait
            
            console.log(`\nüîç INITIAL CHECK RESULTS:`);
            console.log(`Found ${result.total_count} workflows, ${result.running_count} still running`);

            // ‚úÖ MONITOR UNTIL ALL COMPLETE (no forcing)
            while (!result.all_complete && attempts < maxAttempts) {
              attempts++;
              console.log(`\n‚è≥ ATTEMPT ${attempts}/${maxAttempts}:`);
              console.log(`   Still waiting for: ${result.currently_running?.join(', ') || 'unknown'}`);
              
              await new Promise(resolve => setTimeout(resolve, 60000));  // Wait 1 minute
              result = await checkAllWorkflows();
              
              // ‚úÖ Special check for ZenTorch status
              const zentorchStillRunning = result.currently_running?.find(name => 
                name.toLowerCase().includes('zentorch')
              );
              if (zentorchStillRunning) {
                console.log(`üéØ ZenTorch check still running: ${zentorchStillRunning}`);
              }
            }

            // ‚úÖ FINAL COMPLETION CHECK
            if (!result.all_complete) {
              console.log(`\n‚è∞ TIMEOUT after ${attempts} attempts (${maxAttempts} minutes).`);
              console.log(`‚ö†Ô∏è  Still running: ${result.currently_running?.join(', ') || 'none'}`);
              console.log(`‚ùå FORCED COMPLETION - Some workflows may still be running!`);
              
              result.all_complete = true;
              result.timeout_reason = `Timeout after ${maxAttempts} minutes`;
              result.forced_completion = true;
            } else {
              console.log(`\nüéâ SUCCESS: All workflows completed after ${attempts} attempts! (${attempts} minutes)`);
            }

            return result;

      - name: Send Final Status Notification
        env:
          ZENDNNL_WEBHOOK_URL: ${{ secrets.ZENDNNL_WEBHOOK_URL }}
        run: |
          pr_json='${{ steps.pr_info.outputs.result }}'
          completion_json='${{ steps.wait_for_completion.outputs.result }}'

          PR_NUMBER=$(echo "$pr_json" | jq -r '.number // "N/A"')
          PR_TITLE=$(echo "$pr_json" | jq -r '.title // "N/A"' | sed 's/"/\\"/g' | sed "s/'/\\'/g")
          PR_URL=$(echo "$pr_json" | jq -r '.url // "N/A"')
          PR_AUTHOR=$(echo "$pr_json" | jq -r '.author // "N/A"')
          HEAD_SHA=$(echo "$pr_json" | jq -r '.head_sha // "N/A"')
          SHORT_SHA=$(echo "$HEAD_SHA" | cut -c1-7)

          # Safe parsing with defaults
          ALL_COMPLETE=$(echo "$completion_json" | jq -r '.all_complete // false')
          TOTAL_COUNT=$(echo "$completion_json" | jq -r '.total_count // 0')
          RUNNING_COUNT=$(echo "$completion_json" | jq -r '.running_count // 0')
          EXTERNAL_WORKFLOW_URL=$(echo "$completion_json" | jq -r '.external_workflow_url // ""')
          FORCED_COMPLETION=$(echo "$completion_json" | jq -r '.forced_completion // false')

          WORKFLOWS=$(echo "$completion_json" | jq -c '.workflows // []')
          
          SUCCESS_COUNT=$(echo "$WORKFLOWS" | jq '[.[] | select(.status == "success")] | length')
          FAILED_COUNT=$(echo "$WORKFLOWS" | jq '[.[] | select(.status == "failure")] | length')
          CANCELLED_COUNT=$(echo "$WORKFLOWS" | jq '[.[] | select(.status == "cancelled")] | length')
          SKIPPED_COUNT=$(echo "$WORKFLOWS" | jq '[.[] | select(.status == "skipped")] | length')

          WORKFLOW_TEXTBLOCKS=""
          if [ "$TOTAL_COUNT" -gt 0 ]; then
             echo "Building individual TextBlocks for workflows..."
             WORKFLOW_COUNT=$(echo "$WORKFLOWS" | jq 'length')
             for i in $(seq 0 $((WORKFLOW_COUNT - 1))); do
               NAME=$(echo "$WORKFLOWS" | jq -r ".[$i].name")
               STATUS=$(echo "$WORKFLOWS" | jq -r ".[$i].status | ascii_upcase")
               URL=$(echo "$WORKFLOWS" | jq -r ".[$i].url")
               REPO=$(echo "$WORKFLOWS" | jq -r ".[$i].repository // \"\"")
               
               # Escape quotes for JSON
               NAME_SAFE=$(echo "$NAME" | sed 's/"/\\"/g')
               
               if [ "$REPO" != "$GITHUB_REPOSITORY" ] && [ -n "$REPO" ] && [ "$REPO" != "null" ]; then
                 WORKFLOW_TEXT="‚Ä¢ [$NAME_SAFE]($URL) - **$STATUS** (üìÅ $REPO)"
               else
                 WORKFLOW_TEXT="‚Ä¢ [$NAME_SAFE]($URL) - **$STATUS**"
               fi
               
               # Add TextBlock for this workflow
               TEXTBLOCK='{
                 "type": "TextBlock",
                 "text": "'$WORKFLOW_TEXT'",
                 "wrap": true,
                 "size": "Small",
                 "spacing": "None"
               }'
               
               if [ -z "$WORKFLOW_TEXTBLOCKS" ]; then
                 WORKFLOW_TEXTBLOCKS="$TEXTBLOCK"
               else
                 WORKFLOW_TEXTBLOCKS="$WORKFLOW_TEXTBLOCKS,$TEXTBLOCK"
               fi
             done
           else
            WORKFLOW_TEXTBLOCKS='{
              "type": "TextBlock",
              "text": "‚Ä¢ No workflows found",
              "wrap": true,
              "size": "Small"
              }'
            fi

          # Determine overall status
          if [ "$FAILED_COUNT" -gt 0 ]; then
            ICON="üî¥"
            STATUS_TEXT="‚ùå SOME CHECKS FAILED"
            COLOR="Attention"
          elif [ "$CANCELLED_COUNT" -gt 0 ]; then
            ICON="üü†"
            STATUS_TEXT="üü† SOME CHECKS CANCELLED"
            COLOR="Warning"
          elif [ "$FORCED_COMPLETION" = "true" ]; then
            ICON="üü°"
            STATUS_TEXT="‚è∞ TIMEOUT - SOME CHECKS MAY STILL BE RUNNING"
            COLOR="Warning"
          elif [ "$ALL_COMPLETE" = "true" ] && [ "$SUCCESS_COUNT" -gt 0 ]; then
            ICON="üü¢"
            STATUS_TEXT="‚úÖ ALL CHECKS PASSED"
            COLOR="Good"
          elif [ "$ALL_COMPLETE" = "true" ] && [ "$TOTAL_COUNT" -eq 0 ]; then
            ICON="‚ö™"
            STATUS_TEXT="‚ö™ NO WORKFLOWS FOUND"
            COLOR="Default"
          else
            ICON="üü°"
            STATUS_TEXT="‚è≥ CHECKS IN PROGRESS"
            COLOR="Warning"
          fi

          # Completion status
          if [ "$FORCED_COMPLETION" = "true" ]; then
            COMPLETION_TEXT="‚è∞ Timeout reached - $RUNNING_COUNT workflows may still be running"
          elif [ "$ALL_COMPLETE" = "true" ]; then
            COMPLETION_TEXT="üèÅ All $TOTAL_COUNT workflows completed"
          else
            COMPLETION_TEXT="‚è∞ $RUNNING_COUNT of $TOTAL_COUNT workflows still running"
          fi

          # Escape for JSON
          TITLE_SAFE="$ICON PR #$PR_NUMBER ‚Äî $PR_TITLE"

          # Create final status notification
          cat > card.json <<EOF
          {
            "type": "message",
            "attachments": [
              {
                 "contentType": "application/vnd.microsoft.card.adaptive",
                 "content": {
                    "\$schema": "http://adaptivecards.io/schemas/adaptive-card.json",
                    "type": "AdaptiveCard",
                    "version": "1.4",
                    "body": [
                      {
                         "type": "Container",
                         "items": [
                           {
                              "type": "TextBlock",
                              "text": "$TITLE_SAFE",
                              "wrap": true,
                              "weight": "Bolder",
                              "size": "Medium"
                           },
                           {
                              "type": "TextBlock",
                              "text": "$STATUS_TEXT",
                              "wrap": true,
                              "weight": "Bolder",
                              "color": "$COLOR",
                              "size": "Large"
                           },
                           {
                              "type": "FactSet",
                              "facts": [
                                    { "title": "Author:", "value": "$PR_AUTHOR" },
                                    { "title": "Commit:", "value": "$SHORT_SHA" },
                                    { "title": "Status:", "value": "$COMPLETION_TEXT" },
                                    { "title": "Total Workflows:", "value": "$TOTAL_COUNT" },
                                    { "title": "‚úÖ Passed:", "value": "$SUCCESS_COUNT" },
                                    { "title": "‚ùå Failed:", "value": "$FAILED_COUNT" },
                                    { "title": "üü† Cancelled:", "value": "$CANCELLED_COUNT" },
                                    { "title": "‚è≠Ô∏è Skipped:", "value": "$SKIPPED_COUNT" }
                               ]
                              },
                              {
                                 "type": "TextBlock",
                                 "text": "**All Workflow Results:**",
                                 "wrap": true,
                                 "weight": "Bolder",
                                 "size": "Small",
                                 "spacing": "Medium"
                              },
                              $WORKFLOW_TEXTBLOCKS
                            ]
                          }
                        ],
                        "actions": [
                          {
                             "type": "Action.OpenUrl",
                             "title": "View PR",
                             "url": "$PR_URL"
                          },
                          {
                             "type": "Action.OpenUrl",
                             "title": "View All Checks",
                             "url": "https://github.com/${{ github.repository }}/pull/$PR_NUMBER/checks"
                          },
                          {
                              "type": "Action.OpenUrl",
                              "title": "View Commit",
                              "url": "https://github.com/${{ github.repository }}/commit/$HEAD_SHA"
                          }$(if [ -n "$EXTERNAL_WORKFLOW_URL" ]; then echo ',
                          {
                              "type": "Action.OpenUrl",
                              "title": "View ZenTorch Build",
                              "url": "'$EXTERNAL_WORKFLOW_URL'"
                          }'; fi)
                       ]
                   }
              }
             ]
          }
          EOF
           
           curl -s -H "Content-Type: application/json" \
            -d @card.json \
            "$ZENDNNL_WEBHOOK_URL" || (echo "Failed to send Teams message" && exit 1)

           

         
