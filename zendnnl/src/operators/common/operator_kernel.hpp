/********************************************************************************
# * Copyright (c) 2023-2024 Advanced Micro Devices, Inc. All rights reserved.
# *
# * Licensed under the Apache License, Version 2.0 (the "License");
# * you may not use this file except in compliance with the License.
# * You may obtain a copy of the License at
# *
# *     http://www.apache.org/licenses/LICENSE-2.0
# *
# * Unless required by applicable law or agreed to in writing, software
# * distributed under the License is distributed on an "AS IS" BASIS,
# * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# * See the License for the specific language governing permissions and
# * limitations under the License.
# *******************************************************************************/
#ifndef _ZENAI_OPERATOR_KERNEL_HPP_
#define _ZENAI_OPERATOR_KERNEL_HPP_

#ifdef __linux__
#include <dlfcn.h>
#endif

#include <cstdint>
#include <string>
#include <memory>
#include <type_traits>

#include "memory/memory_utils.hpp"
#include "common/zendnnl_global.hpp"
#include "common/hash_object.hpp"
#include "memory/tensor.hpp"
#include "operators/common/operator_context.hpp"

namespace zendnnl {
namespace ops {

using namespace zendnnl::common;
using namespace zendnnl::memory;
using namespace zendnnl::error_handling;

/** @class op_kernel_t
 *  @brief A base class for operator kernel
 *
 * An operator can have multiple kernels depending on machine ISA, problem size
 * and backend and quantization level.
 * @todo Enable chaining.
 */
template<typename OP_CONTEXT_T>
class op_kernel_t : public hash_object_t {
public:
  /** @brief Parent type */
  using   parent_type      = hash_object_t;

  /** @brief Operator context type as template parameter */
  using   context_type     =  OP_CONTEXT_T;

  /** @brief (key,tensor) map type */
  using   tensor_map_type  =  std::map<std::string, tensor_t>;

  /** @brief Virtual destructor
   *
   *  Virtual since this class acts as virtual base class.
   */
  virtual ~op_kernel_t() = default;

  /**@name Create
   */
  /**@{*/
  /** @brief Create kernel
   *
   * Sets the last status to @c status_t::success to make it a valid
   * hash object, and computes hash. As with any other hash object, its
   * validity can be checked with @c check().
   *
   * Derived classes are expected to override it.
   * @return status_t::success for successful creation.
   */
  virtual status_t create();
  /**@}*/

  /**@name Execute
   */
  /**@{*/
  /** @brief Get an (optional) tensor from a tensor map
   * @param key_ : tensor key.
   * @param tensor_map_ : tensor map.
   * @reurn (optional) tensor mapped to the key.
   */
  std::optional<tensor_t> get_tensor(std::string key_, tensor_map_type& tensor_map_);

  /** @brief Execute the kernel.
   *
   * This is expected to be an optimized implementation of kernel computation.
   * Preferably it should avoid branching if it is not a part of computation and
   * can be moved out of kernel, and any logging except for debug pruposes.
   *
   * Pure virtual function, derived classes are expected to override it. An
   * unimplemented kernel should return @c status_t::unimplemented.
   * @param context_ : operator context.
   * @param inputs_  : input tensor map.
   * @param outputs_ : output tensor map.
   * @return status_t::success for successful execution.
   */
  virtual status_t execute(const context_type& context_,
                           tensor_map_type& inputs_,
                           tensor_map_type& outputs_) = 0;
  /**@}*/

  /** @name Profiling and Diagnostics
   */
  /**@{*/
  /** @brief Set name.
   *
   * Name is relevant only for object identification in logging, profiling
   * and diagnostics. Default is "unknown operator".
   * @return A reference to self.
   */
  void         set_name(std::string name_);

  /** @brief Get name.
   * @return Object name.
   */
  std::string   get_name();
  /**@}*/

  /** @brief Generate object hash.
   *
   * Hash generated by an object uniquely identifies the object, therefore hash is
   * generated by taking all the paramaters that uniquely identify a kernal.
   *
   * For operator kernels hash is for future use.
   * @return Object hash.
   */
  std::size_t  hash() override;

protected:
  //protected constructors to prevent instance creation
  op_kernel_t();
  std::string     operator_name;
  std::string     name;
};

template<typename OP_CONTEXT_T>
op_kernel_t<OP_CONTEXT_T>::op_kernel_t():
  operator_name{"unknown operator"}, name{"unknown kernel"} {
}

template<typename OP_CONTEXT_T>
status_t op_kernel_t<OP_CONTEXT_T>::create() {
  LOG_DEBUG_INFO("<", name, "> Creating op_kernel_t");
  status = status_t::success;
  hash();

  return status;
}

template<typename OP_CONTEXT_T>
std::optional<tensor_t> op_kernel_t<OP_CONTEXT_T>::get_tensor(std::string key_,
                                                              tensor_map_type& tensor_map_) {
    LOG_DEBUG_INFO("<", name, "> Getting tensor for ", key_);
    for (const auto& [k, v] : tensor_map_) {
    if (k == key_)
      return v;
  }
  return std::nullopt;
}

template<typename OP_CONTEXT_T>
void op_kernel_t<OP_CONTEXT_T>::set_name(std::string name_) {
  LOG_DEBUG_INFO("<", name, "> Setting name of opertor as ", name_);
  name = name_;
}

template<typename OP_CONTEXT_T>
std::string op_kernel_t<OP_CONTEXT_T>::get_name() {
  LOG_DEBUG_INFO("<", name, "> Getting name of op_kernel");
  return name;
}

template<typename OP_CONTEXT_T>
std::size_t op_kernel_t<OP_CONTEXT_T>::hash() {
  LOG_DEBUG_INFO("<", name, "> Getting hash_key of op_kernel");
  return hash_key;
}

} //namespace ops
} //namespace zendnnl

#endif
